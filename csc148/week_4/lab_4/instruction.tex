\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{titling}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[utf]{kotex}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\predate{}
\postdate{}

\begin{document}
\title{Lab 4: Abstract Data Type}
\date{}
\maketitle

\section*{1) Stack review}
Open \textit{mystack.py} and first review the given stack implementation and the
\textit{size} function we discussed in lecture.

\bigskip

\noindent Complete the following tasks.

\bigskip

\noindent Note that you should write these as top-level functions, not stack methods.

\bigskip

\noindent While you may use a temporary stack (as we did in lecture for \textit{size}),do not use
any other Python compound data structures, like lists.

\bigskip

\begin{enumerate}[1.]
    \item Write a function that takes a stack of integers and removes all of the items which are greater than 5.
    The other items in the stack, and their relative order, should remain unchanged.

    \item Write a function that takes a stack and returns a new stack that contains each item in the old stack twice in a row.
    We’ll leave it up to you to decide what order to put the copies into in the new stack.

    \bigskip

    Note that because the docstring doesn’t say that the old stack will be mutated,
    the old stack should remain unchanged when the function returns.
\end{enumerate}

\begin{lstlisting}[language=Python,caption={mystack.py},captionpos=b]
    """CSC148 Lab 4: Abstract Data Types

    === CSC148 Winter 2020 ===
    Department of Computer Science,
    University of Toronto

    === Module Description ===
    In this module, you will write two different functions that operate on a Stack.
    Pay attention to whether or not the stack should be modified.
    """
    from typing import Any, List


    ################################################################
    # Task 1: Practice with stacks
    ################################################################
    class Stack:
        """A last-in-first-out (LIFO) stack of items.

        Stores data in a last-in, first-out order. When removing an item from the
        stack, the most recently-added item is the one that is removed.
        """
        # === Private Attributes ===
        # _items:
        #     The items stored in this stack. The end of the list represents
        #     the top of the stack.
        _items: List

        def __init__(self) -> None:
            """Initialize a new empty stack."""
            self._items = []

        def is_empty(self) -> bool:
            """Return whether this stack contains no items.

            >>> s = Stack()
            >>> s.is_empty()
            True
            >>> s.push('hello')
            >>> s.is_empty()
            False
            """
            return self._items == []

        def push(self, item: Any) -> None:
            """Add a new element to the top of this stack."""
            self._items.append(item)

        def pop(self) -> Any:
            """Remove and return the element at the top of this stack.

            Raise an EmptyStackError if this stack is empty.

            >>> s = Stack()
            >>> s.push('hello')
            >>> s.push('goodbye')
            >>> s.pop()
            'goodbye'
            """
            if self.is_empty():
                raise EmptyStackError
            else:
                return self._items.pop()


    class EmptyStackError(Exception):
        """Exception raised when an error occurs."""
        pass


    def size(s: Stack) -> int:
        """Return the number of items in s.

        >>> s = Stack()
        >>> size(s)
        0
        >>> s.push('hi')
        >>> s.push('more')
        >>> s.push('stuff')
        >>> size(s)
        3
        """
        side_stack = Stack()
        count = 0
        # Pop everything off <s> and onto <side_stack>, counting as we go.
        while not s.is_empty():
            side_stack.push(s.pop())
            count += 1
        # Now pop everything off <side_stack> and back onto <s>.
        while not side_stack.is_empty():
            s.push(side_stack.pop())
        # <s> is restored to its state at the start of the function call.
        # We consider that it was not mutated.
        return count


    # TODO: implement this function!
    def remove_big(s: Stack) -> None:
        """Remove the items in <stack> that are greater than 5.

        Do not change the relative order of the other items.

        >>> s = Stack()
        >>> s.push(1)
        >>> s.push(29)
        >>> s.push(8)
        >>> s.push(4)
        >>> remove_big(s)
        >>> s.pop()
        4
        >>> s.pop()
        1
        >>> s.is_empty()
        True
        """
        pass


    # TODO: implement this function!
    def double_stack(s: Stack) -> Stack:
        """Return a new stack that contains two copies of every item in <stack>.

        We'll leave it up to you to decide what order to put the copies into in
        the new stack.

        >>> s = Stack()
        >>> s.push(1)
        >>> s.push(29)
        >>> new_stack = double_stack(s)
        >>> s.pop()  # s should be unchanged.
        29
        >>> s.pop()
        1
        >>> s.is_empty()
        True
        >>> new_items = []
        >>> new_items.append(new_stack.pop())
        >>> new_items.append(new_stack.pop())
        >>> new_items.append(new_stack.pop())
        >>> new_items.append(new_stack.pop())
        >>> sorted(new_items)
        [1, 1, 29, 29]
        """
        pass


    if __name__ == '__main__':
        import doctest
        doctest.testmod()

\end{lstlisting}

\section*{2) Queues}
You learned in the readings this week that a queue is another simple ADT that works
in the opposite way to a stack: when asked to remove an item, a queue always removes
the item that was added first, making it a “first-in, first-out” (FIFO) data
structure.

\bigskip

\noindent Any time we’d like to model a lineup (of people at the grocery store, for example),
queues are a natural choice.

\bigskip

\noindent Here are the operations supported by the Queue ADT:

\begin{itemize}
\item \textit{\_\_init\_\_}: initialize a new empty queue
\item \textit{is\_empty()}: return whether the queue is\ empty.
\item \textit{enqueue(item)}: add item to the back of the queue.
\item \textit{dequeue()}: remove and return the front item, if there is one, or None if the queue
is empty.
\end{itemize}

\noindent Your first task is to implement the \textit{Queue} class found in \textit{myqueue.py}.
We strongly recommend you review the stack implementation from lecture to remember
how we used a list to implement the \textit{Stack} class.

\bigskip

\noindent After you’ve finished, complete the functions \textit{product} and \textit{product\_star} in \textit{myqueue.py},
which compute the product of all numbers in a queue (but have an important difference).

\bigskip

\noindent Notice that these are defined outside the class (they are not indented). That makes
them ordinary top-level functions, not methods.

\bigskip

\begin{lstlisting}[language=Python,caption={myqueue.py},captionpos=b]
    """CSC148 Lab 4: Abstract Data Types

    === CSC148 Winter 2020 ===
    Department of Computer Science,
    University of Toronto

    === Module Description ===
    In this module, you will develop an implementation of the Queue ADT.
    It will be helpful to review the stack implementation from lecture.

    After you've implemented the Queue, you'll write two different functions that
    operate on a queue, paying attention to whether or not the queue should be
    modified.
    """
    from typing import Any, List, Optional


    # TODO: implement this class! Note that you'll need at least one private
    # attribute to store items.
    class Queue:
        """A first-in-first-out (FIFO) queue of items.

        Stores data in a first-in, first-out order. When removing an item from the
        queue, the least recently-added item (i.e. the oldest item in the Queue)
        is the one that is removed.
        """
        def __init__(self) -> None:
            """Initialize a new empty queue."""
            pass

        def is_empty(self) -> bool:
            """Return whether this queue contains no items.

            >>> q = Queue()
            >>> q.is_empty()
            True
            >>> q.enqueue('hello')
            >>> q.is_empty()
            False
            """
            pass

        def enqueue(self, item: Any) -> None:
            """Add <item> to the back of this queue.
            """
            pass

        def dequeue(self) -> Optional[Any]:
            """Remove and return the item at the front of this queue.

            Return None if this Queue is empty.
            (We illustrate a different mechanism for handling an erroneous case.)

            >>> q = Queue()
            >>> q.enqueue('hello')
            >>> q.enqueue('goodbye')
            >>> q.dequeue()
            'hello'
            """
            pass


    def product(integer_queue: Queue) -> int:
        """Return the product of integers in the queue.

        Remove all items from the queue.

        Precondition: integer_queue contains only integers.

        >>> q = Queue()
        >>> q.enqueue(2)
        >>> q.enqueue(4)
        >>> q.enqueue(6)
        >>> product(q)
        48
        >>> q.is_empty()
        True
        """
        pass


    def product_star(integer_queue: Queue) -> int:
        """Return the product of integers in the queue.

        Precondition: integer_queue contains only integers.

        >>> primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
        >>> prime_line = Queue()
        >>> for prime in primes:
        ...     prime_line.enqueue(prime)
        ...
        >>> product_star(prime_line)
        6469693230
        >>> prime_line.is_empty()
        False
        """
        pass


    if __name__ == '__main__':
        import doctest
        doctest.testmod()


\end{lstlisting}

\section*{3) Running timing experiments}

Now that you have a complete working implementation of Queue, we’ll introduce a
new technique for evaluating your code: running timing experiments to see how
quickly it runs.

\bigskip

\noindent This is a very simple form of software profiling, which is the act of
measuring the amount of resources (like time) a program takes while its running.

\bigskip

\noindent In fact, PyCharm has a built-in profiler, but that’s more advanced than what we
need for this course, and so you’ll use a simpler profiling library that comes
with Python.

\bigskip

\begin{enumerate}[1.]
    \item Your first task is to open \textit{timequeue.py} and follow the instructions
    contained within it to complete the timing experiment.

    \item After you’ve run your experiment, you should notice that your two queue
    operations \textit{enqueue} and \textit{dequeue} behave quite differently.

    \bigskip

    While one seems to take the same amount of time no matter how many items are
    in the queue, the other takes longer and longer as the number of items are in
    the queue.

    \bigskip

    Compare your notes with other groups.
    Which end of a Python list seems to be the “slow” end? Do you have a guess
    as to why this might be the case? (If you don't: don't worry! You'll learn
    about this in later weeks.)

\end{enumerate}

\bigskip

If you still have time, continue on to the additional exercises!

\begin{lstlisting}[language=Python,caption={timequeue.py},captionpos=b]
    """CSC148 Lab 4: Abstract Data Types

    === CSC148 Winter 2020 ===
    Department of Computer Science,
    University of Toronto

    === Module Description ===
    This module runs timing experiments to determine how the time taken
    to enqueue or dequeue grows as the queue size grows.
    """
    from timeit import timeit
    from typing import List, Tuple

    from myqueue import Queue


    ###########################################################
    # Task 3: Running timing experiments
    ###########################################################
    # TODO: implement this function
    def _setup_queues(qsize: int, n: int) -> List[Queue]:
        """Return a list of <n> queues, each of the given size."""
        # Experiment preparation: make a list containing <n> queues,
        # each of size <qsize>.
        # You can "cheat" here and set your queue's _items attribute directly
        # to a list of the appropriate size by writing something like
        #
        #     queue._items = list(range(qsize))
        #
        # to save a bit of time in setting up the experiment.
        pass


    def time_queue() -> None:
        """Run timing experiments for Queue.enqueue and Queue.dequeue."""
        # The queue sizes to try.
        # You can change these values if you'd like.
        queue_sizes = [10000, 20000, 40000, 80000, 160000]

        # The number of times to call a single enqueue or dequeue operation.
        trials = 200

        # This loop runs the timing experiment. It has three main steps:
        for queue_size in queue_sizes:
            #   1. Initialize the sample queues.
            queues = _setup_queues(queue_size, trials)

            #   2. For each one, calling the function "timeit", takes three
            #      arguments:
            #        - a *string* representation of a piece of code to run
            #        - the number of times to run it (just 1 for us)
            #        - globals is a technical argument that you DON'T need to
            #          care about
            time = 0
            for queue in queues:
                time += timeit('queue.enqueue(1)', number=1, globals=locals())

            #   3. Report the total time taken to do an enqueue on each queue.
            print(f'enqueue: Queue size {queue_size:>7}, time {time}')

        # TODO: using the above loop as an analogy, write a second timing
        # experiment here that runs dequeue on the given queues, and reports the
        # time taken. Note that you can reuse most of the same code.
        for queue_size in queue_sizes:
            pass


    # TODO: implement this function
    def time_queue_lists() -> Tuple[List[int], List[float], List[float]]:
        """Run timing experiments for Queue.enqueue and Queue.dequeue.

        Return lists storing the results of the experiments.  See the lab
        handout for further details.
        """
        pass


    if __name__ == '__main__':
        time_queue()
\end{lstlisting}

\section*{4) Additional exercises}
\subsection*{Graphing your results}
Let’s make our timing experiment a bit more visually appealing. Rather than print
out a bunch of numbers, it would be much more satisfying to take these values and
plot them on a graph to display.

\bigskip

\noindent To do this, you’ll need to do a few things:

\begin{enumerate}[1.]
    \item Implement \textit{time\_queue\_lists}, a modified version of your timing
    experiment function that returns a tuple containing three lists:

    \begin{itemize}
        \item A list of queue sizes it tried
        \item A list of the corresponding times to run enqueue for each queue size
        \item A list of the corresponding times to run dequeue for each queue size
    \end{itemize}

    \bigskip

    Note that each of your lists should have the same length.

    \item To actually plot the data, we’ll use the Python library \textit{matplotlib},
    which is an extremely powerful and popular library for plotting all sorts of
    data.

    \bigskip

    If you’re on a Teaching Lab machine, you already have this library installed.

    \bigskip

    If you’re on your own machine, you should have already installed this library
    by following the CSC148 Software Guide. (Look for the section on installing
    Python libraries.)

    \bigskip

    Add the statement \textit{import matplotlib.pyplot as plt} to the top of \textit{timequeue.py},
    and make sure you can still run your file without error.

    \bigskip

    \item To get a basic 2-D plot of your timing data, work your way through the
    first part of \href{https://matplotlib.org/users/pyplot_tutorial.html}{this guide} (Links to an external site.). (Ignore all of the
    references to “numpy”, which is another Python library we aren’t using in this
    course. Also ignore the other sections after the first one; the whole tutorial
    is pretty long!)

    \bigskip

    You can use an x-axis range of 0-200000 and a y-axis range of 0-0.02 (feel
    free to adjust the y-axis depending on how long the experiments take to run
    on your computer).

    \item If you still have time, explore! There’s lots of customization you can
    do with \textit{matplotlib} to make your graphs really pretty.
\end{enumerate}

\subsection*{Undo and redo}
As we discussed in lecture, one of the most common applications of stacks is in
implementing an “undo” or “back” functionality in various contexts, from website
browsing to editing documents.

\bigskip

\noindent Your task here is to write a program which repeatedly prompts the user
for a string, and stores the strings in a stack except for when the user types
``UNDO''. Int his case, rather than storing the string ``UNDO'', it prints out
the most recently stored string, and removes it from the stack.

\bigskip

\noindent Once you have that working, implement redo functionality using a second stack:
when the user types “REDO”, your program should print the most recently ``undone''
string, and push the string back onto the original stack.

\bigskip

\noindent The user should be able to ``REDO'' multiple times to restore multiple strings in
a row.

\bigskip

\noindent What should happen if a user types in ``REDO'', and then begins entering new strings?

\bigskip

\noindent Get some ideas from \href{https://en.wikipedia.org/wiki/Undo#Redo_models}{here}.
\end{document}
