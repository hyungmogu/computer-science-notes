\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage[utf]{kotex}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\begin{document}
\title{CSC148 Worksheet 16 Solution}
\author{Hyungmo Gu}
\maketitle

\section*{Question 1}
\begin{enumerate}[a.]
    \item

    The doctests for the base case is

    \begin{lstlisting}[language=python]
    """
    >>> nested_list_contains(1,1)
    True
    >>> nested_list_contains(1,2)
    False
    """
    \end{lstlisting}

    \bigskip

    Using this fact, we can write

    \begin{lstlisting}[language=python,caption={worksheet\_16\_q1a\_solution}]
    from typing import Union, List

    def nested_list_contains(obj: Union[int, List], item: int) -> bool:
        """Return whether the given item appears in <obj>.
        Note that if <obj> is an integer, this function checks whether
        <item> is equal to <obj>.

        >>> nested_list_contains(1,1)
        True
        >>> nested_list_contains(1,2)
        False
        """

        if isinstance(self, int):
            return obj == item
    \end{lstlisting}

    \item

    Consider the following doctest

    \begin{lstlisting}[language=python]
    """
    >>> nested_list_contains([4,2,2,[6,5,7,[8]]],8)
    True
    """
    \end{lstlisting}

    \bigskip


    Using the base case from question 1.a, and the basic recursive design recipe,
    we can conclude the algorithm will behave as follows

    \begin{mdframed}

    1) 4 $\to$ $4 == item$? $\to$ False

    2) 2 $\to$ $2 == item$? $\to$ False

    3) 2 $\to$ False

    4)[6,5,7,[8]] $\to$ Recursion

    \hspace{10mm} 5) 6 $\to$ $6 == item$? $\to$ False

    \hspace{10mm} 6) 5 $\to$ $5 == item$? $\to$ False

    \hspace{10mm} 7) 7 $\to$ $7 == item$? $\to$ False

    \bigskip

    \hspace{10mm} 8) [8] $\to$ Recursion

    \hspace{10mm} \hspace{10mm} 9) 8 $\to$ $8 == item$? $\to$  True (function terminates)

    \bigskip

    11) Function Terminates until the end of recursion

    \end{mdframed}

    \bigskip

    Now, no new parameters other than \textit{obj} and \textit{item} are required,
    since

    \begin{enumerate}[1.]
        \item for the traversing and checking of elements, they are done using
        the two parameters.

        \item for bringing the value `True' to user, it is done
        by repeatedly ending the recursive function call early with the value

        \item for brining the value `False' to user, it is done by
        returning False at the end.

    \end{enumerate}

    \item

    \begin{lstlisting}[language=python, caption={worksheet\_16\_q1c\_solution}]
    from typing import Union, List


    def nested_list_contains(obj: Union[int, List], item: int) -> bool:
        """Return whether the given item appears in <obj>.
        Note that if <obj> is an integer, this function checks whether
        <item> is equal to <obj>.

        >>> nested_list_contains([4,2,2,[6,5,7,[8]]],8)
        True
        >>> nested_list_contains([4,2,2,[6,5,7,[8]]],9)
        False
        """

        if isinstance(self, int):
            return obj == item
        else:
            # ==================== (Solution) =======================
            for sublist in obj:
                result = nested_list_contains(sublist, item)

                if result:
                    return result

            return False
            # =======================================================
    \end{lstlisting}


\end{enumerate}

\section*{Question 2}
\begin{enumerate}[a.]
    \item The doctests for the base case is

    \begin{lstlisting}[language=python]
    """
    >>> first_at_depth(1,2)
    None
    """
    \end{lstlisting}

    \bigskip

    Using this fact, we can write

    \begin{lstlisting}[language=python,caption={worksheet\_16\_q2a\_solution}]
    from typing import Union, List, Optional


    def first_at_depth(obj: Union[int, List], d: int) -> Optional[int]:
        """Return the first (leftmost) item in <obj> at depth <d>.
        Return None if there is no item at depth <d>.
        Precondition: d >= 0.

        >>> first_at_depth(1,2)
        None
        """

        if isinstance(obj, int):
            return None
    \end{lstlisting}
    \item

    \bigskip

    First, we need to write doctests for the function call on input of some complexity.

    \bigskip

    Consider the following doctests.

    \begin{lstlisting}[language=python]
    """
    >>> first_at_depth([1,2,[3,4,[5,6]]],1)
    1
    >>> first_at_depth([1,2,[3,4,[5,6]]],3)
    5
    >>> first_at_depth([1,2,[3,4,[5,6]]],4)
    None
    >>> first_at_depth([[1,2,[3]],4,[[5],6]],3)
    3
    """
    \end{lstlisting}

    \bigskip

    Second, we need to write down the relevant recursive calls for each sub-nested-list of input.

    \bigskip

    The recursive calls for the example \textit{first\_at\_depth([1,2,[3,4,[5,6]]],3)}
    is as follows

    \begin{mdframed}

        1) 1 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

        2) 2 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

        3) [3,4,[5,6]] $\to$ Recursion

        \bigskip

        \hspace{10mm} 4) 3 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

        \hspace{10mm} 5) 4 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

        \hspace{10mm} 6) [5,6] $\to$ Recursion

        \bigskip

        \hspace{10mm} \hspace{10mm} 7) 5 $\to$ is current\_depth == 3? $\to$ True $\to$ return 5

        \bigskip

        8) Function Terminates with return value 5 until the end of recursion

    \end{mdframed}

    \bigskip

    Finally, we need to think about the extra parameters for each function.

    \bigskip

    It follows from above that the extra parameter required for this function is
    \textit{current\_depth}. To add this parameter, we need to change function
    \textit{first\_at\_depth} from

    \begin{lstlisting}[language=python,keepspaces=false]
    first_at_depth(obj: Union[int, List], d: int) -> Optional[int]:
    \end{lstlisting}

    to

    \begin{lstlisting}[language=python,keepspaces=false]
    first_at_depth(obj: Union[int, List], d: int, current_depth: int) -> Optional[int]:
    \end{lstlisting}

    \bigskip

    \begin{mdframed}
        \underline{\textbf{Rough Work:}}

        \bigskip

        \begin{enumerate}[1.]
            \item Write a doctest for the function call on input of some complexity

            \bigskip

            First, we need to write a doctest for the function call on input of some complexity

            \bigskip

            \begin{mdframed}

            \bigskip

            First, we need to write doctests for the function call on input of some complexity.

            \bigskip

            Consider the following doctests.

            \begin{lstlisting}[language=python]
            """
            >>> first_at_depth([1,2,[3,4,[5,6]]],1)
            1
            >>> first_at_depth([1,2,[3,4,[5,6]]],3)
            5
            >>> first_at_depth([1,2,[3,4,[5,6]]],4)
            None
            >>> first_at_depth([[1,2,[3]],4,[[5],6]],3)
            3
            """
            \end{lstlisting}

            \end{mdframed}

            \item Write down the relevant recursive calls for each sub-nested-list of input.

            \bigskip

            Second, we need to write down the relevant recursive calls for each sub-nested-list of input.

            \bigskip

            \begin{mdframed}

            \bigskip

            Second, we need to write down the relevant recursive calls for each sub-nested-list of input.

            \bigskip

            The recursive calls for the example \textit{first\_at\_depth([1,2,[3,4,[5,6]]],3)}
            is as follows

            \begin{mdframed}

                1) 1 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

                2) 2 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

                3) [3,4,[5,6]] $\to$ Recursion

                \bigskip

                \hspace{10mm} 4) 3 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

                \hspace{10mm} 5) 4 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

                \hspace{10mm} 6) [5,6] $\to$ Recursion

                \bigskip

                \hspace{10mm} \hspace{10mm} 7) 5 $\to$ is current\_depth == 3? $\to$ True $\to$ return 5

                \bigskip

                8) Function Terminates with return value 5 until the end of recursion

            \end{mdframed}
            \end{mdframed}

            \item Think about the extra parameters for each function.

            \bigskip

            Finally, we need to think about the extra parameters for each function.

            \bigskip

            \begin{mdframed}

            Finally, we need to think about the extra parameters for each function.

            \bigskip

            It follows from above that the extra parameter required for this function is
            \textit{current\_depth}. To add this parameter, we need to change function
            \textit{first\_at\_depth} from

            \begin{lstlisting}[language=python,keepspaces=false]
            first_at_depth(obj: Union[int, List], d: int) -> Optional[int]:
            \end{lstlisting}

            to

            \begin{lstlisting}[language=python,keepspaces=false]
            first_at_depth(obj: Union[int, List], d: int, current_depth: int) -> Optional[int]:
            \end{lstlisting}

            \end{mdframed}
        \end{enumerate}

        \bigskip

        \begin{mdframed}
        First, we need to write doctests for the function call on input of some complexity.

        \bigskip

        Consider the following doctests.

        \begin{lstlisting}[language=python]
        """
        >>> first_at_depth([1,2,[3,4,[5,6]]],1)
        1
        >>> first_at_depth([1,2,[3,4,[5,6]]],3)
        5
        >>> first_at_depth([1,2,[3,4,[5,6]]],4)
        None
        >>> first_at_depth([[1,2,[3]],4,[[5],6]],3)
        3
        """
        \end{lstlisting}

        \bigskip

        Second, we need to write down the relevant recursive calls for each sub-nested-list of input.

        \bigskip

        The recursive calls for the example \textit{first\_at\_depth([1,2,[3,4,[5,6]]],3)}
        is as follows

        \begin{mdframed}

            1) 1 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

            2) 2 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

            3) [3,4,[5,6]] $\to$ Recursion

            \bigskip

            \hspace{10mm} 4) 3 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

            \hspace{10mm} 5) 4 $\to$ is current\_depth == 3? $\to$ False $\to$ return None

            \hspace{10mm} 6) [5,6] $\to$ Recursion

            \bigskip

            \hspace{10mm} \hspace{10mm} 7) 5 $\to$ is current\_depth == 3? $\to$ True $\to$ return 5

            \bigskip

            8) Function Terminates with return value 5 until the end of recursion

        \end{mdframed}

        \bigskip

        Finally, we need to think about the extra parameters for each function.

        \bigskip

        It follows from above that the extra parameter required for this function is
        \textit{current\_depth}. To add this parameter, we need to change function
        \textit{first\_at\_depth} from

        \begin{lstlisting}[language=python,keepspaces=false]
        first_at_depth(obj: Union[int, List], d: int) -> Optional[int]:
        \end{lstlisting}

        to

        \begin{lstlisting}[language=python,keepspaces=false]
        first_at_depth(obj: Union[int, List], d: int, current_depth: int) -> Optional[int]:
        \end{lstlisting}

        \end{mdframed}
    \end{mdframed}

    \bigskip

    \begin{mdframed}
    \underline{\textbf{Correct Solution:}}

    \bigskip

    First, we need to write doctests for the function call on input of some complexity.

    \bigskip

    Consider the following doctests.

    \begin{lstlisting}[language=python]
    """
    >>> first_at_depth([1,2,[3,4,[5,6]]],1)
    1
    >>> first_at_depth([1,2,[3,4,[5,6]]],3)
    5
    >>> first_at_depth([1,2,[3,4,[5,6]]],4)
    >>> first_at_depth([[1,2,[3]],4,[[5],6]],3)
    3
    """
    \end{lstlisting}

    \bigskip

    Second, we need to write down the relevant recursive calls for each sub-nested-list of input.

    \bigskip

    The recursive calls for the example \textit{first\_at\_depth([1,2,[3,4,[5,6]]],3)}
    is as follows

    \begin{mdframed}

        1) 1 $\to$ \color{red}is d == 0\color{black}? $\to$ False $\to$ return None

        2) 2 $\to$ \color{red}is d == 0\color{black}? $\to$ False $\to$ return None

        3) [3,4,[5,6]] $\to$ Recursion

        \bigskip

        \hspace{10mm} 4) 3 $\to$ \color{red}is d == 0\color{black}? $\to$ False $\to$ return None

        \hspace{10mm} 5) 4 $\to$ \color{red}is d == 0\color{black}? $\to$ False $\to$ return None

        \hspace{10mm} 6) [5,6] $\to$ Recursion

        \bigskip

        \hspace{10mm} \hspace{10mm} 7) 5 $\to$ \color{red}is d == 0\color{black}? $\to$ True $\to$ return 5

        \bigskip

        8) Function Terminates with return value 5 until the end of recursion

    \end{mdframed}

    \bigskip

    Finally, we need to think about the extra parameters for each function.

    \bigskip

    It follows from above that \color{red}we have everything we need to
    execute the function\color{black}\:and the extra parameter \color{red}is not
    required\color{black}.

    \end{mdframed}

    \item

    \begin{lstlisting}[language=python,caption={worksheet\_16\_q2c\_solution.py}]
    from typing import Union, List, Optional


    def first_at_depth(obj: Union[int, List], d: int) -> Optional[int]:
        """Return the first (leftmost) item in <obj> at depth <d>.
        Return None if there is no item at depth <d>.
        Precondition: d >= 0.

        >>> first_at_depth(1,2)
        >>> first_at_depth(1,0)
        1
        >>> first_at_depth([1,2,[3,4,[5,6]]],1)
        1
        >>> first_at_depth([1,2,[3,4,[5,6]]],3)
        5
        >>> first_at_depth([1,2,[3,4,[5,6]]],4)
        >>> first_at_depth([[1,2,[3]],4,[[5],6]],3)
        3
        """

        if isinstance(obj, int):
            if d != 0:
                return None
            return obj

        else:
        # ==================== (Solution) =======================
            for sublist in obj:
                result = first_at_depth(sublist, d - 1)

                if result:
                    return result

            return None
        # =======================================================

    if __name__ =='__main__':
        import doctest
        doctest.testmod()
    \end{lstlisting}


\end{enumerate}

\end{document}