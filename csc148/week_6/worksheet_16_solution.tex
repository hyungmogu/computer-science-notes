\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage[utf]{kotex}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\begin{document}
\title{CSC148 Worksheet 16 Solution}
\author{Hyungmo Gu}
\maketitle

\section*{Question 1}
\begin{enumerate}[a.]
    \item

    The doctests for the base case is

    \begin{lstlisting}[language=python]
    """
    >>> nested_list_contains(1,1)
    True
    >>> nested_list_contains(1,2)
    False
    """
    \end{lstlisting}

    \bigskip

    Using this fact, we can write

    \begin{lstlisting}[language=python,caption={worksheet\_16\_q1a\_solution}]
    from typing import Union, List

    def nested_list_contains(obj: Union[int, List], item: int) -> bool:
        """Return whether the given item appears in <obj>.
        Note that if <obj> is an integer, this function checks whether
        <item> is equal to <obj>.

        >>> nested_list_contains(1,1)
        True
        >>> nested_list_contains(1,2)
        False
        """

        if isinstance(self, int):
            return obj == item
    \end{lstlisting}

    \item

    Consider the following doctest

    \begin{lstlisting}[language=python]
    """
    >>> nested_list_contains([4,2,2,[6,5,7,[8]]],8)
    True
    """
    \end{lstlisting}

    \bigskip


    Using the base case from question 1.a, and the basic recursive design recipe,
    we can conclude the algorithm will behave as follows

    \begin{mdframed}

    1) 4 $\to$ $4 == item$? $\to$ False

    2) 2 $\to$ $2 == item$? $\to$ False

    3) 2 $\to$ False

    4)[6,5,7,[8]] $\to$ Recursion

    \hspace{10mm} 5) 6 $\to$ $6 == item$? $\to$ False

    \hspace{10mm} 6) 5 $\to$ $5 == item$? $\to$ False

    \hspace{10mm} 7) 7 $\to$ $7 == item$? $\to$ False

    \bigskip

    \hspace{10mm} 8) [8] $\to$ Recursion

    \hspace{10mm} \hspace{10mm} 9) 8 $\to$ $8 == item$? $\to$  True (function terminates)

    \bigskip

    11) Function Terminates until the end of recursion

    \end{mdframed}

    \bigskip

    Now, no new parameters other than \textit{obj} and \textit{item} are required,
    since

    \begin{enumerate}[1.]
        \item for the traversing and checking of elements, they are done using
        the two parameters.

        \item for bringing the value `True' to user, it is done
        by repeatedly ending the recursive function call early with the value

        \item for brining the value `False' to user, it is done by
        returning False at the end.

    \end{enumerate}

    \item

    \begin{lstlisting}[language=python, caption={worksheet\_16\_q1c\_solution}]
    from typing import Union, List


    def nested_list_contains(obj: Union[int, List], item: int) -> bool:
        """Return whether the given item appears in <obj>.
        Note that if <obj> is an integer, this function checks whether
        <item> is equal to <obj>.

        >>> nested_list_contains([4,2,2,[6,5,7,[8]]],8)
        True
        >>> nested_list_contains([4,2,2,[6,5,7,[8]]],9)
        False
        """

        if isinstance(self, int):
            return obj == item
        else:
            # ==================== (Solution) =======================
            for sublist in obj:
                result = nested_list_contains(sublist, item)

                if result:
                    return result

            return False
            # =======================================================
    \end{lstlisting}


\end{enumerate}

\section*{Question 2}
\begin{enumerate}[a.]
    \item The doctests for the base case is

    \begin{lstlisting}[language=python]
    """
    >>> first_at_depth(1,2)
    None
    """
    \end{lstlisting}

    \bigskip

    Using this fact, we can write

    \begin{lstlisting}[language=python,caption={worksheet\_16\_q2a\_solution}]
    from typing import Union, List, Optional


    def first_at_depth(obj: Union[int, List], d: int) -> Optional[int]:
        """Return the first (leftmost) item in <obj> at depth <d>.
        Return None if there is no item at depth <d>.
        Precondition: d >= 0.

        >>> first_at_depth(1,2)
        None
        """

        if isinstance(obj, int):
            return None
    \end{lstlisting}

\end{enumerate}

\end{document}