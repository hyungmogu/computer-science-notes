\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{titling}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[utf]{kotex}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\predate{}
\postdate{}

\begin{document}
\title{Lab 5: Linked Lists Solution}
\date{}
\maketitle

\section*{3) Augmenting our linked list implementation}
It makes sense that our implementation of \textit{LinkedList.\_\_len\_\_} is so
slow; but how is the built-in \textit{list.\_\_len\_\_} so much faster?

\bigskip

\noindent It turns out that built-in Python lists use an additional attribute to
store their length, so that whenever \textit{list.\_\_len\_\_} is called, it simply
returns the value of this attribute.

\bigskip

\noindent The process of adding an extra attribute to an existing data structure
is known as augmentation, and is very common in computer science. Every data
structure augmentation poses a question of trade-offs:

\begin{itemize}
    \item The benefit of augmenting is that the extra attribute makes certain operations simpler and/or more efficient to implement.
    \item The cost of augmenting is that this extra attribute increases the complexity of the data structure implementation.

    In particular, such attributes often have representation invariants associated with them that must be maintained every time the data structure is mutated.
\end{itemize}

\bigskip

\begin{enumerate}[1.]
    \item Create a copy of your \textit{LinkedList} class (you can pick a name for the copy),
    and add a new private attribute \textit{\_length} to the class documentation and initializer.

    \bigskip

    Write down a representation invariant for this new attribute; you can use
    English here, but try to be precise without using the word “length” in your
    description. (Hint: how do we define length in terms of the nodes of a list?)

    \bigskip

    \begin{mdframed}
    \begin{lstlisting}[language=python,caption={task\_3\_step\_1\_solution.py}]
    class LinkedList:
        """A linked list implementation of the List ADT.
        """
        # === Private Attributes ===
        # _first:
        #     The first node in the linked list, or None if the list is empty.
        # _length:
        #     The number of nodes in the linked list.
        #
        # === Representational Invariants ===
        # - _length >= 0
    \end{lstlisting}
    \end{mdframed}

    \item Update each mutating method to preserve your representation invariant for this new attribute.
    (Why don’t we need to worry about the non-mutating methods?)

    \begin{mdframed}
    \begin{lstlisting}[language=python,caption={task\_3\_step\_2\_solution.py}]
    class LinkedList:
        """A linked list implementation of the List ADT.
        """
        # === Private Attributes ===
        # _first:
        #     The first node in the linked list, or None if the list is empty.
        # _length:
        #     The number of nodes in the linked list.
        #
        # === Representational Invariants ===
        # - _length >= 0
        _first: Optional[_Node]

        def  __init__(self, items: list) -> None:
            """ Initialize a new linked list containing the given items.

                The first node in the linked list contains the first item in <items>
            """

            index = 0
            while index < len(items):
                items[index] = _Node(items[index])

                if index > 0:
                    items[index-1].next = items[index]
                index += 1

            self._first = items[0]
            # ======= (Task 3, Step 2) =======
            self._length = len(items)
            # ================================
        ...

        def insert(self, index: int, item: Any) -> None:
            """Insert a the given item at the given index in this list.

            Raise IndexError if index > len(self) or index < 0.
            Note that adding to the end of the list is okay.

            # >>> lst = LinkedList([1, 2, 10, 200])
            # >>> lst.insert(2, 300)
            # >>> str(lst)
            # '[1 -> 2 -> 300 -> 10 -> 200]'
            # >>> lst.insert(5, -1)
            # >>> str(lst)
            # '[1 -> 2 -> 300 -> 10 -> 200 -> -1]'
            # >>> lst.insert(100, 2)
            # Traceback (most recent call last):
            # IndexError
            """
            # Create new node containing the item
            new_node = _Node(item)

            if index == 0:
                self._first, new_node.next = new_node, self._first
            else:
                # Iterate to (index-1)-th node.
                curr = self._first
                curr_index = 0
                while curr is not None and curr_index < index - 1:
                    curr = curr.next
                    curr_index += 1

                if curr is None:
                    raise IndexError
                else:
                    # Update links to insert new node
                    curr.next, new_node.next = new_node, curr.next
                    # ======= (Task 3, Step 2) =======
                    self._length += 1
                    # ================================

    \end{lstlisting}

    \bigskip

    There is no need to worry about non-mutating methods because the number of
    nodes in linked list doesn't change.
    \end{mdframed}

    \item Now let’s enjoy the benefit of this augmentation!

    \bigskip

    Modify your new class’ \textit{\_\_len\_\_} method to simply return this new
    attribute.

    \textit{Use doctests wisely to ensure you’ve made the correct changes for this and the previous step.}

    \bigskip

    \begin{mdframed}
    \begin{lstlisting}[language=python,caption={task\_3\_step\_3\_solution.py}]
        class LinkedList:
        """A linked list implementation of the List ADT.
        """
        # === Private Attributes ===
        # _first:
        #     The first node in the linked list, or None if the list is empty.
        # _length:
        #     The number of nodes in the linked list.
        #
        # === Representational Invariants ===
        # - _length >= 0
        _first: Optional[_Node]

        def  __init__(self, items: list) -> None:
            """ Initialize a new linked list containing the given items.

                The first node in the linked list contains the first item in <items>
            """

            index = 0
            while index < len(items):
                items[index] = _Node(items[index])

                if index > 0:
                    items[index-1].next = items[index]
                index += 1
            # ============ (Task 3, Step 3) ============
            self._first = items[0] if len(items) > 0 else None
            # ==========================================
            self._length = len(items)

        ...
        def insert(self, index: int, item: Any) -> None:
            """Insert a the given item at the given index in this list.

            Raise IndexError if index > len(self) or index < 0.
            Note that adding to the end of the list is okay.

            # >>> lst = LinkedList([1, 2, 10, 200])
            # >>> lst.insert(2, 300)
            # >>> str(lst)
            # '[1 -> 2 -> 300 -> 10 -> 200]'
            # >>> lst.insert(5, -1)
            # >>> str(lst)
            # '[1 -> 2 -> 300 -> 10 -> 200 -> -1]'
            # >>> lst.insert(100, 2)
            # Traceback (most recent call last):
            # IndexError
            """
            # Create new node containing the item
            new_node = _Node(item)

            if index == 0:
                self._first, new_node.next = new_node, self._first
            else:
                # Iterate to (index-1)-th node.
                curr = self._first
                curr_index = 0
                while curr is not None and curr_index < index - 1:
                    curr = curr.next
                    curr_index += 1

                if curr is None:
                    raise IndexError
                else:
                    # Update links to insert new node
                    curr.next, new_node.next = new_node, curr.next
                    self._length += 1


        # ------------------------------------------------------------------------
        # Lab Task 1
        # ------------------------------------------------------------------------
        # TODO: implement this method
        # NOTE: The doctest will not run until task 3
        # ============ (Task 3, Step 3) ============
        def __len__(self) -> int:
            """Return the number of elements in this list.

            >>> lst = LinkedList([])
            >>> len(lst)              # Equivalent to lst.__len__()
            0
            >>> lst = LinkedList([1, 2, 3])
            >>> len(lst)
            3
            """
            return self._length
        # ==========================================

        ...
        # TODO: implement this method
        # ============ (Task 3, Step 3) ============
        def __setitem__(self, index: int, item: Any) -> None:
            """Store item at position <index> in this list.

            Raise IndexError if index >= len(self).

            >>> lst = LinkedList([1, 2, 3])
            >>> lst[0] = 100  # Equivalent to lst.__setitem__(0, 100)
            >>> lst[1] = 200
            >>> lst[2] = 300
            >>> str(lst)
            '[100 -> 200 -> 300]'
            """

            curr = self._first
            i = 0

            while (curr is not None) and (i <= index):
                if index != i:
                    curr = curr.next
                    i += 1
                    continue

                curr.item = item
                return

            raise IndexError
        # ==========================================
    \end{lstlisting}
    \end{mdframed}

    \item Finally, perform some additional timing tests to demonstrate that you really have
    improved the efficiency of \textit{\_\_len\_\_}.

    \begin{mdframed}

    In comparison to previous result of \textit{\_\_len\_\_}, time taken stays
    constant over input sizes.

    \bigskip

    This is a significant improvement.

    \bigskip

    \begin{lstlisting}
    LinkedList] Size   1000: 3.918999999998063e-06
    [LinkedList] Size   2000: 2.317000000001679e-06
    [LinkedList] Size   4000: 2.640999999997673e-06
    [LinkedList] Size   8000: 2.5440000000001572e-06
    [LinkedList] Size  16000: 2.6340000000013575e-06
    \end{lstlisting}
    \end{mdframed}

\end{enumerate}
\end{document}
