\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{titling}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[utf]{kotex}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\predate{}
\postdate{}

\begin{document}
\title{Lab 5: Linked Lists Solution}
\date{}
\maketitle

\section*{1) Practice with linked lists}

For this task: we have commented out the doctests in the methods. You will not
be able to run them until you finish step (3) of this task, at which point you
may uncomment them. We recommend you read all of the steps in this task before
you begin.

\bigskip

\begin{enumerate}[1.]
    \item
    In the starter code, find and read the docstring of the method \textit{\_\_len\_\_},
    and then implement it.

    \bigskip

    You already implemented this method in this week’s prep, but it’s good practice
    to implement it again. (And if you missed this week’s prep, do it now!)

    \begin{mdframed}
        \begin{lstlisting}[language=python,caption={task\_1\_step\_1\_solution.py}]
        class LinkedList:
            ...
            def __len__(self) -> int:
                """Return the number of elements in this list.

                # >>> lst = LinkedList([])
                # >>> len(lst)              # Equivalent to lst.__len__()
                # 0
                # >>> lst = LinkedList([1, 2, 3])
                # >>> len(lst)
                # 3
                """
                curr = self._first
                count = 0

                while curr is not None:
                    curr = curr.next
                    count += 1

                return count
        \end{lstlisting}
    \end{mdframed}

    \item Then, implement the methods \textit{count}, \textit{index}, and \textit{\_\_setitem\_\_}.

    \begin{mdframed}
        \underline{\textbf{count:}}

        \bigskip

        \begin{lstlisting}[language=python,caption={task\_1\_step\_2\_solution.py}]
        class LinkedList:
            ...
            def count(self, item: Any) -> int:
                """Return the number of times <item> occurs in this list.

                Use == to compare items.

                # >>> lst = LinkedList([1, 2, 1, 3, 2, 1])
                # >>> lst.count(1)
                # 3
                # >>> lst.count(2)
                # 2
                # >>> lst.count(3)
                # 1
                """

                count = 0
                curr = self._first

                while curr is not None:

                    if curr.item == item:
                        count += 1

                    curr = curr.next

                return count
        \end{lstlisting}

        \bigskip

        \underline{\textbf{index:}}

        \bigskip

        \begin{lstlisting}[language=python,caption={task\_1\_step\_2\_solution.py}]
        class LinkedList:
            ...
            def index(self, item: Any) -> int:
                """Return the index of the first occurrence of <item> in this list.

                Raise ValueError if the <item> is not present.

                Use == to compare items.

                # >>> lst = LinkedList([1, 2, 1, 3, 2, 1])
                # >>> lst.index(1)
                # 0
                # >>> lst.index(3)
                # 3
                # >>> lst.index(148)
                # Traceback (most recent call last):
                # ValueError
                """

                index = 0

                curr = self._first

                while curr is not None:
                    if curr.item == item:
                        return index

                    curr = curr.next
                    index += 1

                raise ValueError
        \end{lstlisting}

        \bigskip

        \underline{\textbf{\_\_setitem\_\_:}}

        \bigskip

        \begin{lstlisting}[language=python,caption={task\_1\_step\_2\_solution.py}]
        class LinkedList:
            ...
            def __setitem__(self, index: int, item: Any) -> None:
                """Store item at position <index> in this list.

                Raise IndexError if index >= len(self).

                # >>> lst = LinkedList([1, 2, 3])
                # >>> lst[0] = 100  # Equivalent to lst.__setitem__(0, 100)
                # >>> lst[1] = 200
                # >>> lst[2] = 300
                # >>> str(lst)
                # '[100 -> 200 -> 300]'
                """

                curr = self.first
                i = 0

                while (curr is not None) and (i <= index):
                    if index == i:
                        curr.item = item

                    curr = curr.next
                    i += 1

                raise IndexError
        \end{lstlisting}
    \end{mdframed}

    \item You might have noticed that all the doctests were commented out in the previous part.

    This is because they use a more powerful initializer than the one we’ve started with.

    \bigskip

    Your final task in this section is to implement a new initializer with the following interface:

    \bigskip

    \begin{lstlisting}[language=python]
        def __init__(self, items: list) -> None:
            """Initialize a new linked list containing the given items.

            The first node in the linked list contains the first item
            in <items>.
            """
    \end{lstlisting}

    \bigskip

    The lecture notes suggest one way to do this using \textit{append}; however,
    here we want you to try doing this without using \textit{append} (or any other helper
    method).

    \bigskip

    There are many different ways you could implement this method, but the key idea
    is that you need to loop through \textit{items}, create a new \textit{\_Node} for each
    item, link the nodes together, and initialize \textit{self.\_first}.

    \bigskip

    Spend time drawing some pictures before writing any code!

    \bigskip

    \begin{mdframed}
    \begin{lstlisting}[language=python,caption={task\_1\_step\_3\_solution.py}]
    class LinkedList:
        """A linked list implementation of the List ADT.
        """
        # === Private Attributes ===
        # _first:
        #     The first node in the linked list, or None if the list is empty.
        _first: Optional[_Node]

        def  __init__(self, items: list) -> None:
            """ Initialize a new linked list containing the given items.

                The first node in the linked list contains the first item in <items>
            """

            index = 0
            while index < len(items):
                items[index] = _Node(items[index])

                if index > 0:
                    items[index-1].next = items[index]
                index += 1

            self._first = items[0]
    \end{lstlisting}
    \end{mdframed}

\end{enumerate}

\end{document}
