\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{titling}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[utf]{kotex}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\predate{}
\postdate{}

\begin{document}
\title{Lab 5: Linked Lists}
\date{}
\maketitle

\section*{1) Practice with linked lists}

For this task: we have commented out the doctests in the methods. You will not
be able to run them until you finish step (3) of this task, at which point you
may uncomment them. We recommend you read all of the steps in this task before
you begin.

\bigskip

\begin{enumerate}[1.]
    \item In the starter code, find and read the docstring of the method \textit{\_\_len\_\_},
    and then implement it.

    \bigskip

    You already implemented this method in this week’s prep, but it’s good practice
    to implement it again. (And if you missed this week’s prep, do it now!)

    \item Then, implement the methods \textit{count}, \textit{index}, and \textit{\_\_setitem\_\_}.

    \item You might have noticed that all the doctests were commented out in the previous part.

    This is because they use a more powerful initializer than the one we’ve started with.

    \bigskip

    Your final task in this section is to implement a new initializer with the following interface:

    \bigskip

    \begin{lstlisting}[language=python]
        def __init__(self, items: list) -> None:
            """Initialize a new linked list containing the given items.

            The first node in the linked list contains the first item
            in <items>.
            """
    \end{lstlisting}

    \bigskip

    The lecture notes suggest one way to do this using \textit{append}; however,
    here we want you to try doing this without using \textit{append} (or any other helper
    method).

    \bigskip

    There are many different ways you could implement this method, but the key idea
    is that you need to loop through \textit{items}, create a new \textit{\_Node} for each
    item, link the nodes together, and initialize \textit{self.\_first}.

    \bigskip

    Spend time drawing some pictures before writing any code!

\end{enumerate}

\section*{2) Timing \textit{\_\_len\_\_} for linked lists vs. array-based lists}

\begin{enumerate}[1.]
    \item Most methods take longer to run on large inputs than on small inputs,
    although this is not always the case.

    \bigskip

    Look at your code for your linked list method \textit{\_\_len\_\_}.

    Do you expect it to take longer to run on a larger
    linked list than on a smaller one?

    \item Pick one the following terms to relate the growth of \textit{\_\_len\_\_}'s
    running time vs. input size, and justify.
    \begin{itemize}
        \item constant, logarithmic, linear, quadratic, exponential
    \end{itemize}

    \item Complete the code in \textit{time\_lists.py} to measure how running
    time for your \textit{\_\_len\_\_} method changes as the size of the linked
    list grows. Is it as you predicted?

    \bigskip

    Now’s let’s assess and compare the performance of Python’s built-in \textit{list}.
    You can do this by simply adding it to the list of types that \textit{list\_class}
    iterates over. What do you notice about the behaviour of calling \textit{len} on
    a built-in \textit{list}?

\end{enumerate}

\section*{3) Augmenting our linked list implementation}
It makes sense that our implementation of \textit{LinkedList.\_\_len\_\_} is so
slow; but how is the built-in \textit{list.\_\_len\_\_} so much faster?

\bigskip

\noindent It turns out that built-in Python lists use an additional attribute to
store their length, so that whenever \textit{list.\_\_len\_\_} is called, it simply
returns the value of this attribute.

\bigskip

\noindent The process of adding an extra attribute to an existing data structure
is known as augmentation, and is very common in computer science. Every data
structure augmentation poses a question of trade-offs:

\begin{itemize}
    \item The benefit of augmenting is that the extra attribute makes certain operations simpler and/or more efficient to implement.
    \item The cost of augmenting is that this extra attribute increases the complexity of the data structure implementation.

    In particular, such attributes often have representation invariants associated with them that must be maintained every time the data structure is mutated.
\end{itemize}

\bigskip

\begin{enumerate}[1.]
    \item Create a copy of your \textit{LinkedList} class (you can pick a name for the copy),
    and add a new private attribute \textit{\_length} to the class documentation and initializer.

    \bigskip

    Write down a representation invariant for this new attribute; you can use
    English here, but try to be precise without using the word “length” in your
    description. (Hint: how do we define length in terms of the nodes of a list?)

    \item Update each mutating method to preserve your representation invariant for this new attribute.
    (Why don’t we need to worry about the non-mutating methods?)

    \item Now let’s enjoy the benefit of this augmentation!

    \bigskip

    Modify your new class’ \textit{\_\_len\_\_} method to simply return this new
    attribute.

    \textit{Use doctests wisely to ensure you’ve made the correct changes for this and the previous step.}

    \item Finally, perform some additional timing tests to demonstrate that you really have
    improved the efficiency of \textit{\_\_len\_\_}.

\end{enumerate}

\section*{4) Additional exercises}
\subsection*{Generalizing \textit{\_\_getitem\_\_}}
The implementation we’ve provided for \textit{\_\_getitem\_\_} has many shortcomings
compared to Python’s built-in lists.

\bigskip

\noindent Two features that it doesn’t currently support are negative indexes and slices
(e.g., \textit{my\_list[2:5]}).

\bigskip

\noindent Your first task here is to investigate the different ways in which Python
supports these operations for built-in Python lists; you can do this by experimenting
yourself in the Python console, or by doing some reading online.

\bigskip

\noindent Then, modify the linked list implementation of \textit{\_\_getitem\_\_}
so that it handles both negative indexes and slices.

\bigskip

\noindent Note that a slice in Python is actually a class: the expression
\textit{my\_list[2:5]} is equivalent to \textit{my\_list.\_\_getitem\_\_(slice(2, 5))}.

\bigskip

\noindent Use \textit{isinstance} to determine whether the input to \textit{\_\_getitem\_\_}
is an integer or a slice.

\bigskip

\noindent The fully general method signature of \textit{\_\_getitem\_\_} should
become:

\bigskip

\begin{lstlisting}[language=python]
    def __getitem__(self, index: Union[int, slice]) -> Union[Any, LinkedList]
\end{lstlisting}

\bigskip

\noindent Note: slicing should always return a new \textit{LinkedList} object.

\bigskip

\noindent This means that for a given slice, you’ll need to create a \textit{LinkedList} and new
\textit{\_Nodes} as well, in a similar manner to how you implemented the more
powerful initializer at the end of Task 1.


\subsection*{Matplotlib Practice}
Use \textit{matplotlib} to plot the results of your timing experiments, using the same
approach as last week (See matplotlib section in lab 4).
\end{document}
