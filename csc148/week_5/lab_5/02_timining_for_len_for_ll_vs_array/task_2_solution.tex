\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{titling}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[utf]{kotex}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\predate{}
\postdate{}

\begin{document}
\title{Lab 5: Linked Lists Solution}
\date{}
\maketitle

\section*{2) Timing \_\_len\_\_ for linked lists vs. array-based lists}

\begin{enumerate}[1.]
    \item Most methods take longer to run on large inputs than on small inputs,
    although this is not always the case.

    \bigskip

    Look at your code for your linked list method \textit{\_\_len\_\_}.

    Do you expect it to take longer to run on a larger
    linked list than on a smaller one?

    \bigskip

    \begin{mdframed}
    Yes, because in order to count the number of nodes in the linked list,
    it has to traverse through all the nodes.
    \end{mdframed}

    \item Pick one the following terms to relate the growth of \textit{\_\_len\_\_}'s
    running time vs. input size, and justify.
    \begin{itemize}
        \item constant, logarithmic, linear, quadratic, exponential
    \end{itemize}

    \begin{mdframed}
    The growth of \textit{\_\_len\_\_}'s running time is \textbf{linear}.

    \bigskip

    First, we need to calculate the number of steps taken by the loop.

    \bigskip

    The code tells us that the loop starts at $0^{th}$ node and increments by
    one until $n-1^{th}$ node in the linked list.

    \bigskip

    Using this fact, we can calculate the loop has

    \begin{align}
        n - 1 - 0 + 1 = n
    \end{align}

    iterations.

    \bigskip

    Because we know each iteration takes a constant time (1 step), we can conclude
    the loop takes total of

    \begin{align}
        n \cdot 1 = n
    \end{align}

    \bigskip

    steps.

    \bigskip

    Finally, adding the constant time operations outside of the loop (1 step),
    we can conclude the algorithm has total running time of $n + 1$, which is
    $\mathcal{O}(n)$.

    \end{mdframed}

    \item Complete the code in \textit{time\_lists.py} to measure how running
    time for your \textit{\_\_len\_\_} method changes as the size of the linked
    list grows. Is it as you predicted?

    \bigskip

    Now’s let’s assess and compare the performance of Python’s built-in \textit{list}.
    You can do this by simply adding it to the list of types that \textit{list\_class}
    iterates over. What do you notice about the behaviour of calling \textit{len} on
    a built-in \textit{list}?

\end{enumerate}

\end{document}
