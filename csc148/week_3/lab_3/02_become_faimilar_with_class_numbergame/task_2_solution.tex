\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{titling}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\predate{}
\postdate{}

\begin{document}
\title{Lab 2 Task 2: Become familiar with class \textit{NumberGame} Solution}
\date{}
\maketitle

\section*{2) Become familiar with class \textit{NumberGame}}
\begin{enumerate}[1.]
    \item What attribute stores the players of the game?

    \begin{itemize}
    \item The players of the game are stored in instance attribute \textit{players}.

    \begin{lstlisting}[language=Python]
    class NumberGame:
        ...
        def __init__(
            self,
            goal: int,
            min_step: int,
            max_step: int,
            players: Tuple[Player, Player]
        ) -> None:
            ...
            self.players = players # <- Here!
    \end{lstlisting}
    \end{itemize}

    \item If \textit{turn} is 15, whose turn is it?

    \bigskip

    \begin{itemize}
        \item

        We need to determine who's turn is at turn 15.

        \bigskip

        The code of method \textit{whose\_turn} tells us

        \bigskip

        \begin{lstlisting}[language=Python]
        class NumberGame:
            ...
            def whose_turn(self, turn: int) -> Player:
                """Return the Player whose turn it is on the given turn number.
                """
                if turn % 2 == 0:
                    return self.players[0]
                else:
                    return self.players[1]
        \end{lstlisting}

        \bigskip

        Using this code, we can conclude that at turn 15, it's player 2's turn.

        % \bigskip

        % \begin{mdframed}
        %     \underline{\textbf{Rough Work:}}

        %     \bigskip

        %     We need to determine who's turn is at turn 15.

        %     \bigskip

        %     \begin{enumerate}[1.]
        %         \item State the code responsible for telling us about player's turn.

        %         \bigskip

        %         \begin{mdframed}

        %             The code of method \textit{whose\_turn} tells us

        %             \begin{lstlisting}[language=Python]
        %             class NumberGame:
        %                 ...
        %                 def whose_turn(self, turn: int) -> Player:
        %                     """Return the Player whose turn it is on the given turn number.
        %                     """
        %                     if turn % 2 == 0:
        %                         return self.players[0]
        %                     else:
        %                         return self.players[1]
        %             \end{lstlisting}

        %         \end{mdframed}

        %         \bigskip

        %         \item Conclude it's player 2's turn at turn 15 using the method

        %         \bigskip

        %         \begin{mdframed}

        %         Using this code, we can conclude that at turn 15, it's player 2's turn.
        %         \end{mdframed}
        %     \end{enumerate}

        %     \begin{mdframed}
        %         We need to determine who's turn is at turn 15.

        %         \bigskip

        %         The code of method \textit{whose\_turn} tells us

        %         \bigskip

        %         \begin{lstlisting}[language=Python]
        %         class NumberGame:
        %             ...
        %             def whose_turn(self, turn: int) -> Player:
        %                 """Return the Player whose turn it is on the given turn number.
        %                 """
        %                 if turn % 2 == 0:
        %                     return self.players[0]
        %                 else:
        %                     return self.players[1]
        %         \end{lstlisting}

        %         \bigskip

        %         Using this code, we can conclude that at turn 15, it's player 2's turn.
        %     \end{mdframed}
        % \end{mdframed}
    \end{itemize}

    \item Write a line of code that would create an instance of \textit{NumberGame}
    that violates one of the representation invariants.

    \begin{itemize}
        \item

        We need write a line of code that violates one of the representational
        invariants.

        \bigskip

        The representational invariant of the initializer of
        \textit{NumberGame} tells us

        \bigskip

        \begin{lstlisting}[language=Python]
        """
        ...
        Precondition: 0 < min_step <= max_step <= goal
        """
        \end{lstlisting}

        \bigskip

        It follows from this fact that the representational invariant is
        invalidated when $goal \leq 0$.

        \bigskip

        Then, using this fact, we can write that a line of code that
        invalidates representational invariants is

        \bigskip

        \begin{lstlisting}[language=Python]
        NumberGame(-1,3,10,(Player(),Player()))
        \end{lstlisting}

        % \bigskip

        % \begin{mdframed}
        %     \underline{\textbf{Rough Work:}}

        %     \bigskip

        %     We need write a line of code that violates one of the representational invariants.

        %     \bigskip

        %     \begin{enumerate}[1.]
        %         \item State the precondition of initialization method of \textit{NumberGame}.

        %         \bigskip

        %         \begin{mdframed}

        %             The representational invariant of the initializer of
        %             \textit{NumberGame} tells us

        %             \begin{lstlisting}[language=Python]
        %             """
        %             ...
        %             Precondition: 0 < min_step <= max_step <= goal
        %             """
        %             \end{lstlisting}

        %         \end{mdframed}

        %         \bigskip

        %         \item Show representational invariant is violated when \textit{goal}
        %         is less than 0 using the precondition

        %         \begin{mdframed}
        %         It follows from this fact that the representational invariant is
        %         invalidated when $goal \leq 0$.

        %         \end{mdframed}

        %         \item Write a line of code that invalidates one of the representational invariants using the precondition

        %         \begin{mdframed}
        %         Then, using this fact, we can write that a line of code that
        %         invalidates representational invariants is

        %         \begin{lstlisting}[language=Python]
        %         NumberGame(-1,3,10,(Player(),Player()))
        %         \end{lstlisting}
        %         \end{mdframed}

        %     \end{enumerate}

        %     \begin{mdframed}
        %     The representational invariant of the initializer of
        %     \textit{NumberGame} tells us

        %     \bigskip

        %     \begin{lstlisting}[language=Python]
        %     """
        %     ...
        %     Precondition: 0 < min_step <= max_step <= goal
        %     """
        %     \end{lstlisting}

        %     \bigskip

        %     It follows from this fact that the representational invariant is
        %     invalidated when $goal \leq 0$.

        %     \bigskip

        %     Then, using this fact, we can write that a line of code that
        %     invalidates representational invariants is

        %     \bigskip

        %     \begin{lstlisting}[language=Python]
        %     NumberGame(-1,3,10,(Player(),Player()))
        %     \end{lstlisting}

        %     \end{mdframed}
        % \end{mdframed}

    \end{itemize}

    \item Which of the representation invariants is it possible to violate by
    constructing a \textit{NumberGame} improperly?

    \begin{itemize}
        \item

        The following code tells us that the constructor of class \textit{NumberGame} has four
        representational invariants as parameter types

        \bigskip

        \begin{lstlisting}[language=Python]
        def __init__(self, goal: int, min_step: int, max_step: int,
            players: Tuple[Player, Player]) -> None:
        \end{lstlisting}

        \bigskip

        , and one as precondition

        \bigskip

        \begin{lstlisting}[language=Python]
        """
        ...
        Precondition: 0 < min_step <= max_step <= goal
        """
        \end{lstlisting}

        \bigskip

        Using these facts, we can conclude that any of the five
        representational invariants can become violated when

        \begin{enumerate}[1.]
            \item One or more arguments in \textit{\_\_init\_\_} are of incorrect data type
            \item $0 \geq \textit{min\_step} > \textit{max\_step} > \textit{goal}$
        \end{enumerate}

        % \bigskip

        % \begin{mdframed}
        %     \underline{\textbf{Rough Work:}}

        %     \bigskip

        %     We need to determine which of the representational invariant is
        %     possible to violate by improperly constructing \textit{NumberGame}.

        %     \bigskip

        %     \begin{enumerate}[1.]
        %         \item State that the initializer of \textit{NumberGame} has
        %         five representational invariants, four regarding parameter types
        %         and one regarding precondition.

        %         \begin{mdframed}
        %         The following code tells us that the constructor of class \textit{NumberGame} has four
        %         representational invariants as parameter types

        %         \bigskip

        %         \begin{lstlisting}[language=Python]
        %         def __init__(self, goal: int, min_step: int, max_step: int,
        %             players: Tuple[Player, Player]) -> None:
        %         \end{lstlisting}

        %         \bigskip

        %         , and one as precondition

        %         \bigskip

        %         \begin{lstlisting}[language=Python]
        %         """
        %         ...
        %         Precondition: 0 < min_step <= max_step <= goal
        %         """
        %         \end{lstlisting}

        %         \end{mdframed}

        %         \item Show that constructor of \textit{NumberGame} is violated when arguements
        %         are not of correct type, or precondition is not satisfied, using the stated fact.

        %         \begin{mdframed}
        %         Using these facts, we can conclude that any of the five
        %         representational invariants can become violated when

        %         \begin{enumerate}[1.]
        %             \item One or more arguments in \textit{\_\_init\_\_} are of incorrect data type
        %             \item $0 \geq \textit{min\_step} > \textit{max\_step} > \textit{goal}$
        %         \end{enumerate}

        %         \end{mdframed}

        %     \end{enumerate}

        %     \begin{mdframed}
        %     The following code tells us that the constructor of class \textit{NumberGame} has four
        %     representational invariants as parameter types

        %     \bigskip

        %     \begin{lstlisting}[language=Python]
        %     def __init__(self, goal: int, min_step: int, max_step: int,
        %         players: Tuple[Player, Player]) -> None:
        %     \end{lstlisting}

        %     \bigskip

        %     , and one as precondition

        %     \bigskip

        %     \begin{lstlisting}[language=Python]
        %     """
        %     ...
        %     Precondition: 0 < min_step <= max_step <= goal
        %     """
        %     \end{lstlisting}

        %     \bigskip

        %     Using these facts, we can conclude that any of the five
        %     representational invariants can become violated when

        %     \begin{enumerate}[1.]
        %         \item One or more arguments in \textit{\_\_init\_\_} are of incorrect data type
        %         \item $0 \geq \textit{min\_step} > \textit{max\_step} > \textit{goal}$
        %     \end{enumerate}

        %     \end{mdframed}
        % \end{mdframed}

    \end{itemize}

    \item List all the places in this class where a \textit{Player} is stored, an instance
    attribute of \textit{Player} is accessed or set, or a method is called on a \textit{Player}

    \begin{itemize}
        \item  We need to find all places in \textit{NumberGame} class where one a
        \textit{Player} is stored, where an instance attribute of \textit{Player}
        is accessed or set, or where a method is called on a \textit{Player}.

        \bigskip

        First, we need to find where \textit{Player} is stored.

        \bigskip

        By observation, we can conclude \textit{Player} is stored in
        instance attribute \textit{players} under the initializer method.

        \begin{lstlisting}[language=Python]
        class NumberGame:
            def __init__(self, goal: int, min_step: int, max_step: int,
                players: Tuple[Player, Player]) -> None:
                """Initialize this NumberGame.

                Precondition: 0 < min_step <= max_step <= goal
                """

                self.players = players # Here
        \end{lstlisting}

        \bigskip

        Second, we need to find where the instance attribute of \textit{Player} is accessed or set.

        \bigskip

        By observation, we can conclude there are two places where one or more instance
        attributes of \textit{Player} is accessed or set.

        \bigskip

        The first one is inside \textit{play} method.

        \begin{lstlisting}[language=Python]
        class NumberGame:
            ...
            def play(self) -> str:
                ...
                winner = self.whose_turn(self.turn - 1)
                return winner.name # <- Here!!
        \end{lstlisting}

        \bigskip

        The second one is inside \textit{play\_one\_turn} method.

        \begin{lstlisting}[language=Python]
        class NumberGame:
            ...
            def play_one_turn(self) -> None:
                ...
                print(f'{next_player.name} moves {amount}.') # <- Here!!
                print(f'Total is now {self.current}.')
        \end{lstlisting}

        \bigskip

        Finally, we need to find where method of \textit{Player} is
        called.

        \bigskip

        By observation, we can conclude one method of \textit{Player}
        is used, and it is called inside \textit{play\_one\_turn} method.

        \bigskip

        \begin{lstlisting}[language=Python]
        class NumberGame:
            ...
            def play_one_turn(self) -> None:
                next_player = self.whose_turn(self.turn)
                amount = next_player.move( # <- Here!!
                    self.current,
                    self.min_step,
                    self.max_step,
                    self.goal
                )
        \end{lstlisting}

    \end{itemize}

    % \begin{mdframed}
    %     \underline{\textbf{Rough Work:}}

    %     \bigskip

    %     We need to find all places in \textit{NumberGame} class where one a
    %     \textit{Player} is stored, where an instance attribute of \textit{Player}
    %     is accessed or set, or where a method is called on a \textit{Player}.

    %     \bigskip

    %     \begin{enumerate}[1.]
    %         \item Find where \textit{Player} is stored.

    %         \bigskip

    %         \begin{mdframed}

    %         First, we need to find where \textit{Player} is stored.

    %         \bigskip

    %         By observation, we can conclude \textit{Player} is stored in
    %         instance attribute \textit{players} under the initializer method.

    %         \begin{lstlisting}[language=Python]
    %         class NumberGame:
    %             def __init__(self, goal: int, min_step: int, max_step: int,
    %                 players: Tuple[Player, Player]) -> None:
    %                 """Initialize this NumberGame.

    %                 Precondition: 0 < min_step <= max_step <= goal
    %                 """

    %                 self.players = players # Here
    %         \end{lstlisting}


    %         \end{mdframed}

    %         \item Find where the instance attribute of \textit{Player} is accessed or set.

    %         \bigskip

    %         \begin{mdframed}

    %         Second, we need to find where the instance attribute of \textit{Player} is accessed or set.

    %         \bigskip

    %         By observation, we can conclude there are two places where one or more instance
    %         attributes of \textit{Player} is accessed or set.

    %         \bigskip

    %         The first one is inside \textit{play} method.

    %         \begin{lstlisting}[language=Python]
    %         class NumberGame:
    %             ...
    %             def play(self) -> str:
    %                 ...
    %                 winner = self.whose_turn(self.turn - 1)
    %                 return winner.name # <- Here!!
    %         \end{lstlisting}

    %         \bigskip

    %         The second one is inside \textit{play\_one\_turn} method.

    %         \begin{lstlisting}[language=Python]
    %         class NumberGame:
    %             ...
    %             def play_one_turn(self) -> None:
    %                 ...
    %                 print(f'{next_player.name} moves {amount}.') # <- Here!!
    %                 print(f'Total is now {self.current}.')
    %         \end{lstlisting}

    %         \end{mdframed}

    %         \item Find where a method of \textit{Player} is called.

    %         \bigskip

    %         \begin{mdframed}

    %         Finally, we need to find where method of \textit{Player} is
    %         called.

    %         \bigskip

    %         By observation, we can conclude one method of \textit{Player}
    %         is used, and it is called inside \textit{play\_one\_turn} method.

    %         \bigskip

    %         \begin{lstlisting}[language=Python]
    %         class NumberGame:
    %             ...
    %             def play_one_turn(self) -> None:
    %                 next_player = self.whose_turn(self.turn)
    %                 amount = next_player.move( # <- Here!!
    %                     self.current,
    %                     self.min_step,
    %                     self.max_step,
    %                     self.goal
    %                 )
    %         \end{lstlisting}

    %         \end{mdframed}
    %     \end{enumerate}

    % \end{mdframed}
\end{enumerate}

\end{document}
