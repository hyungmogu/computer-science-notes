\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage[utf]{kotex}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\lhead{CSC 209}
\rhead{Review 9 Solution}

\begin{document}
\title{CSC 209 Review 9 Solution}
\maketitle

\bigskip

\begin{enumerate}[1.]
    \item

    \begin{enumerate}[a)]
        \item 8

        \begin{mdframed}
        \underline{\textbf{Correct Solution}}

        \bigskip

        \color{red}0\color{black}
        \end{mdframed}
        \item 0
        \item 1
        \item 6

        \begin{mdframed}
        \underline{\textbf{Correct Solution}}

        \bigskip

        \color{red}15\color{black}
        \end{mdframed}
    \end{enumerate}

    \bigskip

    \underline{\textbf{Notes}}

    \bigskip

    \begin{itemize}
        \item \texttt{a)} is 0 because

        \bigskip

        $i >> 1 + j >> 1$ is $8 >> 10 >> 1$

        \bigskip

        Which is $0 >> 1$

        \bigskip

        Which is 0.

        \item \texttt{d)} is 15 because

        \bigskip

        $i \hat{} j \& k$ is $7 \hat{} 8 \& 9$

        \bigskip

        which is $7 \hat{} 8$

        \bigskip

        which is $15$

    \end{itemize}

    \item

    Use XOR on target bit using value 1.

    \bigskip

    This is because the operator of two like values equals to 0, and
    unequal values equal to 1.

    \bigskip

    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            a & b & a \^{} b\\
            \hline
            0 & 0  & 0 \\
            0 & 1  & 1 \\
            1 & 0  & 1 \\
            1 & 1  & 0 \\
            \hline
        \end{tabular}
    \end{center}

    \item

    The macro switches the value of \texttt{x} and \texttt{y}.

    \bigskip

    Take for example $x = 100$ (8) and $y = 010$ (4)

    \bigskip

    For the first part of macro, we have $x = x \textsuperscript{$\wedge$} y = 100 \textsuperscript{$\wedge$} 010 = 110$.

    \bigskip

    Taking this to second part of macro, we have $y = y \textsuperscript{$\wedge$} x = 010 \textsuperscript{$\wedge$} 110 = 100$.

    \bigskip

    Lastly, we have $x = x \textsuperscript{$\wedge$} y = 110 \textsuperscript{$\wedge$} 100 = 010$.

    \bigskip

    Thus, we can see the value of $x$ and $y$ are switched.

    \item

\begin{lstlisting}[language=c]
    #define MK_COLOR(red,green,blue) (long) ((blue << 16) | (blue | (green << 8)) | red)
\end{lstlisting}

    \item

\begin{lstlisting}[language=c]
    #define GET_RED(color) (int)(color & 255)

    #define GET_GREEN(color) (int)((color >> 8) & 255)

    #define GET_BLUE(color) (int)((color >> 16) & 255)
\end{lstlisting}

    \item

    \begin{enumerate}[a)]

        \item

        Please see file \texttt{question\_6\_a.c} for details.

        \item

        Please see file \texttt{question\_6\_b.c} for details.

    \end{enumerate}

    \bigskip

    \underline{\textbf{Notes}}

    \begin{itemize}
        \item Unisigned short has at max 4 bits.
        \item Any out-of-bound bits are omitted
    \end{itemize}

    \item

    Please see file \texttt{question\_7.c} for details.

    \item

    \begin{enumerate}[a)]
        \item Returns first \texttt{n} bits of 1
        \item Extracts \texttt{n} bits from \texttt{m-n+2}th bit
    \end{enumerate}

    \item

    \begin{enumerate}[a)]
        \item

        Please see file \texttt{question\_9\_a.c} for details.

        \item

        Please see file \texttt{question\_9\_b.c} for details.
    \end{enumerate}

    \item

    Please see file \texttt{question\_10.c} for details.

    \item

    The precedence of \&, \^{}, and $\vert$ is lower than the equality operators.

    \bigskip

    So, given \texttt{if (key\_code \& (SHIFT\_BIT $\vert$ CTRL\_BIT $\vert$ ALT\_BIT) == 0)},
    (SHIFT\_BIT $\vert$ CTRL\_BIT $\vert$ ALT\_BIT) == 0) will be evaluated first, which is incorrect.

    \bigskip

    To fix this problem, add parenthesis to \texttt{key\_code \& (SHIFT\_BIT $\vert$ CTRL\_BIT $\vert$ ALT\_BIT)}.

    \item

    The precedence of + is higher than $<<$. So, \texttt{8 + low\_byte} in
    \texttt{high\_byte $<<$ 8 + low\_byte} will be evaluated before \texttt{high\_byte $<<$}.

    \bigskip

    To fix this problem, add parenthesis to \texttt{high\_byte $<<$ 8}.

    \item

    All bits in \texttt{n} are gradually reduced to 0, starting from the right-most bit.

    \item

\begin{lstlisting}[language=c]
    union ieee_float {
        float value;
        struct {
            unsigned int fraction: 23;
            unsigned int exponent: 8;
            unsigned int sign: 1;
        } parts;
    };
\end{lstlisting}

    \bigskip

    \begin{mdframed}
    \underline{\textbf{Correct Solution}}

    \bigskip

\begin{lstlisting}[language=c]
    struct ieee_float {
        unsigned int fraction: 23;
        unsigned int exponent: 8;
        unsigned int sign: 1;
    };
\end{lstlisting}
    \end{mdframed}

    \item

    \begin{enumerate}[a)]
        \item

        This is because the value of \texttt{int}'s sign in some compiler is
        oppsite to the others (e.g. 0 represents a positive sign in some compiler,
        where as 1 represents a positivie sign in other compilers).

        \item

        To avoid this problem, use \texttt{unsinged int} instead.
    \end{enumerate}

    \item

\begin{lstlisting}[language=c]
    typedef unsigned long DWORD;
    typedef unsigned short WORD;
    typedef unsigned char BYTE;

    union {
        struct {
            DWORD eax, ebx, ecx, edx;
        } dword;
        struct {
            WORD axl, axh, bxl, bxh, cxl, cxh, dxl, dxh;
        } word;
        struct {
            BYTE al, ah, ale, ahe, bl, bh, ble, bhe, cl, ch, cle, che, dl, dh, dle, dhe;
        } byte;
    } regs;
\end{lstlisting}

    \item

    Please see \texttt{question\_17.c} for details.

\end{enumerate}

\end{document}