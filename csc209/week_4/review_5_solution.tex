\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage[utf]{kotex}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\lhead{CSC 209}
\rhead{Review 5 Solution}

\begin{document}
\title{CSC 209 Review 5 Solution}
\maketitle

\bigskip

\begin{enumerate}[1.]
    \item

    \bigskip

    \begin{enumerate}[a)]
        \item 14
        \item 34
        \item 4
        \item true
        \item false
    \end{enumerate}

    \underline{\textbf{Notes}}

    \begin{itemize}
        \item \textbf{Pointer Arithematic}

        \begin{itemize}
            \item Adding an integer to a pointer

            \bigskip

            \underline{\textbf{Example}}

            \begin{center}
            \includegraphics[width=\linewidth]{images/review_5_solution_1.png}
            \end{center}

            \bigskip

            \item Subtracting an integer from a pointer

            \bigskip

            \underline{\textbf{Example}}

            \begin{center}
            \includegraphics[width=\linewidth]{images/review_5_solution_2.png}
            \end{center}

            \bigskip

            \item Subtracting one pointer from another

            \bigskip

            \underline{\textbf{Example}}

            \begin{center}
            \includegraphics[width=\linewidth]{images/review_5_solution_3.png}
            \end{center}

        \end{itemize}

        \item \textbf{Comparing pointers}

        \begin{itemize}
            \item Can compare pointers using relational operators (i.e. $<,<=,>,>=$) and the equality operators (i.e. $==, !=$)
            \item Returns 1 if \texttt{true} and 0 if \texttt{false}

            \bigskip

            \underline{\textbf{Example}}

            \bigskip

            \texttt{p = \&a[5];}

            \texttt{q = \&a[1];}

            \bigskip

            \texttt{p $<=$ q} is 0 and \texttt{p $>=$ q} is 1


        \end{itemize}


    \end{itemize}

    \item

    \bigskip

    \texttt{low} and \texttt{high} are memory addresses.

    \bigskip

    So, \texttt{low $+$ high} is out of bound, and it could potentially point to an undesirable or wrong value.

    \bigskip

    To fix this, we subtract the from high value to the low value:

    \bigskip

    \begin{align}
        \texttt{middle} = \frac{\texttt{low $+$ high}}{2}
    \end{align}

    \item

    \bigskip

    I need to write the contents of an array \texttt{a} after the execution of
    statements outlined in problem sheet.

    \bigskip

    After execution, the array would have contents of $[10,9,8,7,6,5,4,3,2,1]$.

    \bigskip

    \underline{\textbf{Notes}}

    \begin{itemize}
        \item \textbf{Combining the * and ++ Operators}

        \begin{itemize}
            \item \texttt{*p++} or \texttt{*{p++}} $\to$ Value of expression is \texttt{*p} before increment; increment \texttt{p} later
            \item \texttt{(*p)++} $\to$ Value of expression is \texttt{*p} before increment; increment \texttt{*p} later
            \item \texttt{*++p} or \texttt{*(++p)} $\to$ Increment \texttt{p} first; value of expression is \texttt{*p} after increment
            \item \texttt{++*p} or \texttt{++(*p)} $\to$ Increment \texttt{*p} first; value of expression is \texttt{*p} after increment
        \end{itemize}

        \bigskip

        \underline{\textbf{Example}}

        \bigskip

        \texttt{a[i++] = j}

        \bigskip

        Means assign the value \texttt{j} to \texttt{a[i]} before increment

        \bigskip

        \underline{\textbf{Example 2}}

        \bigskip

        \begin{center}
        \includegraphics[width=\linewidth]{images/review_5_solution_4.png}
        \end{center}

        Is the same as

        \begin{center}
        \includegraphics[width=\linewidth]{images/review_5_solution_5.png}
        \end{center}
    \end{itemize}

    \item

    I need to re-write prototype \texttt{make\_empty}, \texttt{is\_empty} and \texttt{is\_full}
    of the following code to use the pointer variable \texttt{top\_ptr} instead of the integer
    variable \texttt{top}.

    \bigskip

\begin{lstlisting}[language=c]
    #include <stdbool.h>

    #define STACK_SIZE 100

    /*external variables*/
    int contents[STACK_SIZE]
    int top = 0;

    void make_empty(void) {
        top = 0;
    }

    bool is_empty(void) {
        return top == 0;
    }

    bool is_full(void) {
        return top == STACK_SIZE;
    }
\end{lstlisting}

    \bigskip

    And after re-write using \texttt{top\_ptr} instead of \texttt{top} have:


\begin{lstlisting}[language=c]
    #include <stdbool.h>

    #define STACK_SIZE 100

    /*external variables*/
    int contents[STACK_SIZE]
    int *top_ptr = &contents[0];

    void make_empty(void) {
        top_ptr = &contents[0];
    }

    bool is_empty(void) {
        return top_ptr == &contents[0];
    }

    bool is_full(void) {
        return top_ptr == &contents[STACK_SIZE-1];
    }
\end{lstlisting}

    \item

    First, I need to identify which of the following expressions are illegal
    because of mismatched types.

    \bigskip

    \begin{enumerate}[a)]
        \item \texttt{p $==$ a[0]}
        \item \texttt{p $==$ \&a[0]}
        \item \texttt{*p $==$ a[0]}
        \item \texttt{p[0] == a[0]}
    \end{enumerate}

    \bigskip

    Here, only \texttt{a)} is illegal.

    \bigskip

    Second, I need to write which of the remaining expressions are true.

    \bigskip

    Here, the expressions that return true are \texttt{b)}, \texttt{c)} and \texttt{d)}.

    \bigskip

    \underline{\textbf{Notes}}

    \begin{itemize}
        \item \texttt{*(a+i)} is equal to \texttt{a[i]}
        \item \texttt{*p} and \texttt{a[]} are the same given \texttt{p $==$ a}
        \item \textbf{Using an Array Name as a Pointer}

        \begin{itemize}
            \item The name of an array can be used as a pointer to the first element in the array.

            \bigskip

            \underline{\textbf{Example}}

            \bigskip

            \texttt{int a[10];}

            \bigskip

            \texttt{*a = 7; /* stores 7 in a[0] */}

            \bigskip

            \texttt{*(a+1) = 12; /* stores 7 in a[1] */}

            \bigskip

            \underline{\textbf{Example 2}}

            \bigskip

            \begin{center}
            \includegraphics[width=\linewidth]{images/review_5_solution_6.png}
            \end{center}

        \end{itemize}
    \end{itemize}

    \item

    I need to re-write the following to use pointer arithematic instead
    of array subscripting, and I need to make as few change as possible.

    \bigskip

\begin{lstlisting}[language=c]
    int sum_array(cost int a[], int n) {
        int i, sum;

        sum = 0;

        for (i = 0; i < n; i++)
            sum += a[i];
        return sum;
    }
\end{lstlisting}

    \bigskip

    After making changes to above code to use pointer arithematic, we have

\begin{lstlisting}[language=c]
    int sum_array(cost int a[], int n) {
        int i, sum;

        sum = 0;

        for (i = 0; i < n; i++)
            sum += *(a+i);
        return sum;
    }
\end{lstlisting}

    \item

    I need to write the following using pointer arithematic so it finds an element
    in \texttt{a} that matches to value \texttt{key}. I need to return
    true if there is a match.

    \bigskip

    \texttt{bool search(const int a[], int n, int key);}

    \bigskip

    And the solution is:

\begin{lstlisting}[language=c]
    bool search(cost int a[], int n, int key) {

        for (int i = 0; i < n; i++) {
            if (*(a+i) == key) {
                return true
            }
        }

        return false;
    }
\end{lstlisting}

    \item

    Here, I need to re-write the following function to use pointer arithmetic
    instead of array subscripting.

    \bigskip

\begin{lstlisting}[language=c]
    void store_zeros(cost int a[], int n) {
        int i;

        for (i = 0; i < n; i++) {
            a[i] = 0;
        }
    }
\end{lstlisting}

    \bigskip

    After re-writing above code, we have

\begin{lstlisting}[language=c]
    void store_zeros(cost int a[], int n) {
        int *p;

        for (p = a; p < a + n; p++) {
            *p = 0;
        }
    }
\end{lstlisting}

    \item

    Here, I need to write the function

    \bigskip

    \texttt{double inner\_product(const double *a, const double *b, int n)}

    \bigskip

    using pointer arithmetic such that it returns \texttt{a[0] * b[0] + a[1] *
    b[1] + a[2] * b[2] + ... + a[n-1] * b[n-1]}.

    \bigskip

    The solution is provided below

    \bigskip

\begin{lstlisting}[language=c]
    double inner_product(const double *a, const double *b, int n) {
        double sum = 0, p*;

        p = a;

        while (p < a + n) {
            sum += *a * *b;

            a++;
            b++;
            p++;
        }

        return sum;
    }
\end{lstlisting}

    \bigskip

    \begin{mdframed}
        \underline{\textbf{Correct Solution}}

        \bigskip

\begin{lstlisting}[language=c]
double inner_product(const double *a, const double *b, int n) {
    double sum = 0, *p;

    p = a;

    while (p++ < a + n) {
        sum += *a++ * *b++;
    }

    return sum;
}
\end{lstlisting}

    \end{mdframed}

\end{enumerate}

\end{document}