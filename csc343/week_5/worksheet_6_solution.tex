\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage[utf]{kotex}
\usepackage{hyperref}
\usepackage{accents}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\lhead{CSC 343}
\rhead{Worksheet 6 Solution}

\begin{document}
\title{CSC343 Worksheet 6 Solution}
\maketitle

\begin{enumerate}[1.]
    \item \textbf{Exercise 8.1.1:}

    \bigskip

    \begin{enumerate}[a)]
        \item

    \begin{lstlisting}[language=SQL]
    CREATE VIEW RichExec AS
        SELECT * FROM MovieExec
        WHERE netWorth >= 10000000;
    \end{lstlisting}

        \bigskip

        \underline{\textbf{Notes:}}

        \bigskip

        \begin{itemize}
            \item Virtual Views
            \begin{itemize}
                \item \textbf{Syntax:} CREATE VIEW $<\text{view-name}>$ AS $<\text{view-definition}>$
                \item Contrasts to database that exists in physical storage
                \item Exists in RAM
                \item Is created using query
                \item can be used like a relation

                \bigskip

                \underline{\textbf{Notes:}}

                \bigskip

        \begin{lstlisting}[language=SQL]
        CREATE VIEW ParamountMovies AS
            SELECT title, year
            FROM Movies
            WHERE studioName = 'Paramount';
        \end{lstlisting}
            \end{itemize}
        \end{itemize}

        \item

    \begin{lstlisting}[language=SQL]
    CREATE VIEW StudioPres AS
        SELECT * FROM Movies
        INNER JOIN Studio ON cert# = presC#;
    \end{lstlisting}

        \item

    \begin{lstlisting}[language=SQL]
    CREATE VIEW ExecutiveStar AS
        SELECT * FROM MovieExec
        NATURAL JOIN MovieStar;
    \end{lstlisting}
    \end{enumerate}

    \item \textbf{Exericse 8.1.2:}

    \begin{enumerate}[a)]
        \item

    \begin{lstlisting}[language=SQL]
    SELECT name, gender FROM ExecutiveStar;
    \end{lstlisting}

        \item

    \begin{lstlisting}[language=SQL]
    SELECT name FROM RichExec WHERE netWorth > 10000000;
    \end{lstlisting}

        \item

    \begin{lstlisting}[language=SQL]
    SELECT name FROM StudioPres
    NATURAL JOIN ExecutiveStar
    WHERE netWorth > 50000000
    \end{lstlisting}
    \end{enumerate}

    \item \textbf{Exericse 8.2.1:}

    \bigskip

    \textit{RichExec} is updatable.

    \underline{\textbf{Notes:}}

    \bigskip

    \begin{itemize}
        \item Updatable View Conditions
        \begin{itemize}
            \item The WHERE cluase in CREATE VIEW must not be a subquery
            \item The FROM clause has only one occurence of R
            \item The SELECT clause must include enough attributes
            \item NOT NULL attributes must have default values
            \begin{itemize}
                \item A solution to this is by including the attribute without
                default value in CREATE VIEW
            \end{itemize}

            \bigskip

            \underline{\textbf{Example:}}

            \bigskip

    \begin{lstlisting}[language=SQL]
    Movies(title, year, length, genre, studioName, producerC#)
    Suppose studioName is NOT NULL but has no default value. Then, a fix is:

    CREATE VIEW Paramount AS
        SELECT studioName, title, year
        FROM Movies
        WHERE studioName = 'Paramount';
    \end{lstlisting}

        \end{itemize}
    \end{itemize}

    \bigskip

    \item \textbf{Exericse 8.2.2:}

    \bigskip

    \begin{enumerate}[a)]
        \item No. It is not updatable. Since,

        \begin{enumerate}[1.]
            \item studioName attribute in Movies is NOT NULL without default value
        \end{enumerate}

        \item

    \begin{lstlisting}[language=SQL]
    CREATE TRIGGER DisneyComediesInsert
    INSTEAD OF INSERT ON DisneyComedies
    REFERENCING
        NEW ROW AS NewTuple
    FOR EACH ROW
    INSERT INTO Movies(title, year, length, genre, studioName)
    VALUES(NewTuple.title, NewTuple.year, NewTuple.length, 'comedy', 'Disney');
    \end{lstlisting}

        \bigskip

        \underline{\textbf{Notes:}}

        \bigskip

        \begin{itemize}
            \item Using Trigger in VIEW
            \begin{itemize}
                \item Uses INSTEAD OF in place of BEFORE or AFTER
                \item When event causes the trigger, the trigger is done instead of the event

                \bigskip

                \underline{\textbf{Example:}}

    \begin{lstlisting}[language=SQL]
    CREATE VIEW ParamountMovies AS
        SELECT title, year
        FROM Movies
        WHERE studioName = 'paramount';

    CREATE TRIGGER ParamountInsert
    INSTEAD OF INSERT ON ParamountMovies
    REFERENCING NEW ROW AS NewRow
    FOR EACH ROW
    INSERT INTO Movies(title, year, studioName)
    VALUES(NewRow.title, NewRow.year, 'Paramount');
    \end{lstlisting}

            \end{itemize}
        \end{itemize}

        \item

    \begin{lstlisting}[language=SQL]
    CREATE TRIGGER DisneyComediesInsert
    INSTEAD OF INSERT ON DisneyComedies
    REFERENCING
        NEW ROW AS NewTuple
        OLD ROW AS OldTuple
    FOR EACH ROW
    UPDATE Movies
    SET length=NewTuple.length
    WHERE title=OldTuple.title AND year=OldTuple.year;
    \end{lstlisting}

    \end{enumerate}

    \item \textbf{Exercise 8.2.3}

    \bigskip

    \begin{enumerate}[a)]
        \item No. the view is not updatable. Because for it to be updatable,
        only one relation must exist in FROM
        \item

    \begin{lstlisting}[language=SQL]
    CREATE TRIGGER NewPCInsert
    INSTEAD OF INSERT ON NewPC
    REFERENCING
        NEW ROW AS NewTuple
        OLD ROW AS OldTuple
    FOR EACH ROW
    INSERT INTO PC(model speed, ram, hd ,price)
    VALUES (NewTuple.model, NewTuple.speed, NewTuple.ram, NewTuple.hd, NewTuple.price);

    INSERT INTO Product(maker, model, type)
    VALUES (NewTuple.maker, NewTuple.model, 'pc');
    \end{lstlisting}

        \item

    \begin{lstlisting}[language=SQL]
    CREATE TRIGGER NewPCUpdate
    INSTEAD OF INSERT ON NewPC
    REFERENCING
        NEW ROW AS NewTuple
    FOR EACH ROW
    UPDATE PC
    SET model=NewTuple.model
        speed=NewTuple.speed,
        ram=NewTuple.ram,
        hd=NewTuple.hd,
        price=NewTuple.price;

    UPDATE Product
    SET maker=NewTuple.maker,
        model=NewTuple.model,
        type='pc';
    \end{lstlisting}

        \bigskip

        \begin{mdframed}
            \underline{\textbf{Correct Solution:}}

    \begin{lstlisting}[language=SQL]
    CREATE TRIGGER NewPCUpdate
    INSTEAD OF UPDATE ON NewPC
    REFERENCING
        NEW ROW AS NewTuple
    FOR EACH ROW
    UPDATE PC
    SET model=NewTuple.model
        speed=NewTuple.speed,
        ram=NewTuple.ram,
        hd=NewTuple.hd,
        price=NewTuple.price;

    UPDATE Product
    SET maker=NewTuple.maker,
        model=NewTuple.model,
        type='pc';
    \end{lstlisting}
        \end{mdframed}

        \item

    \begin{lstlisting}[language=SQL]
    CREATE TRIGGER NewPCDelete
    INSTEAD OF DELETE ON NewPC
    REFERENCING
        NEW ROW AS NewTuple
    FOR EACH ROW
    DELETE FROM PC
    WHERE model=NewTuple.model;

    DELETE FROM Product
    WHERE model=NewTuple.model;
    \end{lstlisting}

    \end{enumerate}

    \item

    \begin{enumerate}[a)]
        \item

    \begin{lstlisting}[language=SQL]
    CREATE INDEX studioNameIndex Studio(name)
    \end{lstlisting}

        \bigskip

        \underline{\textbf{Notes:}}

        \bigskip

        \begin{itemize}
            \item Indexes
            \begin{itemize}
                \item \textbf{Syntax (Create Index):}

                CREATE INDEX $<\text{index-name}>$ $R(<\text{attributes}>)$
                \item \textbf{Syntax (Drop Index):}

                DROP INDEX $<\text{index-name}>$
                \item Used to find tuples in a very large database
                \begin{itemize}
                    \item Is efficient
                \end{itemize}
                \item Can be thought as (key, value) pair in a binary search tree
                \item e.g. Declaring Index

    \begin{lstlisting}[language=SQL]
    CREATE INDEX KeyIndex ON Movies(title, year);
    \end{lstlisting}

                \item e.g. Dropping index

    \begin{lstlisting}[language=SQL]
    CREATE INDEX KeyIndex ON Movies(title, year);
    \end{lstlisting}

            \end{itemize}
        \end{itemize}

        \item

    \begin{lstlisting}[language=SQL]
    CREATE INDEX movieExecAddressIndex MovieExec(address)
    \end{lstlisting}

        \item

    \begin{lstlisting}[language=SQL]
    CREATE INDEX movieKeyIndex Movies(genre, length)
    \end{lstlisting}

    \end{enumerate}

    \item \textbf{Exercise 8.4.1:}

    \bigskip

    \begin{tabular}{c|cccc}
        Action & No Index & Star Index & Movie Index & Both Indexes\\
        \hline
        $Q_1$ & 100 & 4 & 100 & 4\\
        \hline
        $Q_2$ & 100 & 100 & 4 & 4\\
        \hline
        $I$ & 2 & 4 & 4 & 6\\
        \hline
        Average & $2 + 100p_1 + 100p_2$ & $4 + 96p_2$ & $4 + 96p_1$ & $6 - 2p_1 - 2p_2$\\
    \end{tabular}

    \bigskip

    \underline{\textbf{Notes:}}

    \bigskip

    \begin{itemize}
        \item Database Tuning
        \begin{itemize}
            \item Index sppeds up queries that can use it
            \item Index should NOT be created when modifications are the frequent
            choice of action
        \end{itemize}
    \end{itemize}

    \item \textbf{Exercise 8.4.2:}

    Omitted for the time being

    \item \textbf{Exercise 8.5.1:}

    \bigskip

    \begin{lstlisting}[language=SQL]
    UPDATE MovieProd
    SET name='New Name'
    WHERE (title, year) IN
    (
        SELECT title, year FROM Movies
        INNER JOIN MovieExecs
        ON Movies.productC# = MovieExec.cert#
        WHERE cert# = '4567'
    );
    \end{lstlisting}

    \bigskip

    \underline{\textbf{Notes:}}

    \bigskip

    \begin{itemize}
        \item Materialized Views
        \begin{itemize}
            \item Stores view in physical storage
        \end{itemize}
    \end{itemize}

\end{enumerate}

\end{document}