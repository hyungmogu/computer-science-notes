\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage[utf]{kotex}
\usepackage{hyperref}
\usepackage{accents}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\lhead{CSC 343}
\rhead{Worksheet 7 Solution}

\begin{document}
\title{CSC343 Worksheet 7 Solution}
\maketitle

\bigskip

\begin{enumerate}[1.]
    \item

    \begin{enumerate}[a)]
        \item
    \begin{lstlisting}[language=c]
    void askUserForPrice() {
        EXEC SQL BEGIN DECLARE SECTION;
            int model;
            float speed;
            int ram;
            int hd;
            float price;
            char maker;
            float targetPrice;

            float minDiff;
            int modelSol;
            float speedSol;
            char makerSol;
        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE execCursor CURSOR FOR
            SELECT * FROM Product NATURAL JOIN PC

        EXEC SQL OPEN execCursor;

        printf("Enter target price:");
        scanf("%f", &targetPrice);

        while(1) {
            EXEC SQL FETCH FROM execCursor INTO :model,
                :speed, :ram, :hd, :price, :maker;

            if (NO_MORE_TUPLES) break;

            if (abs(price - targetPrice) >= minDiff) {
                continue;
            }

            minDiff = abs(price - targetPrice);
            modelSol = model;
            speedSol = speed;
            makerSol = maker;
        }

        EXEC SQL CLOSE execCursor;

        printf("maker=%c, model=%d, speed=%.2f\n", makerSol, modelSol, speedSol);

    }
    \end{lstlisting}

        \bigskip

        \underline{\textbf{Notes:}}

        \bigskip

        \begin{itemize}
            \item EXEC SQL
            \begin{itemize}
                \item Allows to use SQL statements within a host-language program
            \end{itemize}
            \item The DECLARE Section
            \begin{itemize}
                \item is used to declare shared variables
                \item \textbf{Syntax:}

                EXEC SQL BEGIN DECLARE SECTION;

                ... // Variable declarations in any language

                EXEC SQL END DECLARE SECTION;

                \bigskip

                \underline{\textbf{Example:}}

                \bigskip

        \begin{lstlisting}[language=SQL]
        void getStudio() {
            EXEC SQL BEGIN DECLARE SECTION;
                char studioName[50], studioAddr[256]; // <- c variables
                char SQLSTATE[6];
            EXEC SQL END DECLARE SECTION;

            EXEC SQL INSERT INTO Studio(name, address)
                    VALUES (:studioName, :studioAddr);
        }
        \end{lstlisting}
            \end{itemize}

            \item Cursors
            \begin{itemize}
                \item Is the most versatile way to connect SQL queries
                \item \textbf{Syntax:}

                EXEC SQL DECLARE $<\text{cursor name}>$ CURSOR FOR $<\text{query}>$

                \bigskip

                EXEC SQL OPEN $<\text{cursor name}>$;

                ...

                EXEC SQL CLOSE $<\text{cursor name}>$;

                \bigskip

                \underline{\textbf{Example:}}

                \bigskip

        \begin{lstlisting}[language=c]
        void getStudio() {
            EXEC SQL BEGIN DECLARE SECTION;
                char studioName[50], studioAddr[256]; // <- c variables
                char SQLSTATE[6];
            EXEC SQL END DECLARE SECTION;

            EXEC SQL INSERT INTO Studio(name, address)
                        VALUES (:studioName, :studioAddr);
        }
        \end{lstlisting}

                \bigskip

                \underline{\textbf{Example in Python:}}

                \bigskip

        \begin{lstlisting}[language=python]
        import sqlite3
        connection = sqlite3.connect("company.db")

        cursor = connection.cursor()

        staff_data = [ ("William", "Shakespeare", "m", "1961-10-25"),
                        ("Frank", "Schiller", "m", "1955-08-17"),
                        ("Jane", "Wall", "f", "1989-03-14") ]

        for p in staff_data:
            format_str = """INSERT INTO employee (staff_number, fname, lname, gender, birth_date)
            VALUES (NULL, "{first}", "{last}", "{gender}", "{birthdate}");"""

            sql_command = format_str.format(first=p[0], last=p[1], gender=p[2], birthdate = p[3])
            cursor.execute(sql_command)
        \end{lstlisting}
            \end{itemize}

            \item Fetch Statement
            \begin{itemize}
                \item fetch data from the result table one row at a time
                \item \textbf{Syntax:}

                EXEC SQL FETCH FROM $<\text{cursor name}>$ INTO $<\text{list of variables}>$

                \bigskip

                \underline{\textbf{Example:}}

                \bigskip

        \begin{lstlisting}[language=c]
        void worthRanges() {
            int i, digits, counts[15];
            EXEC SQL BEGIN DECLARE SECTION;
                int worth;
                char SQLSTATE[6];
            EXEC SQL END DECLARE SECTION;
            EXEC SQL DECLARE execCursor CURSOR FOR
                SELECT netWorth FROM MovieExec;

            EXEC SQL OPEN execCursor;
            for (i=1; i < 15; i++) counts[i] = 0;
            while(1) {
                EXEC SQL FETCH FROM execCursor INTO :worth; // fetches a row of value from movieExec and stores in worth
                if (NO_MORE_TUPLES) break;

                ...
            }
        }
        \end{lstlisting}

            \end{itemize}
        \end{itemize}

        \item

    \begin{lstlisting}[language=c]
    void findLaptops() {
        EXEC SQL BEGIN DECLARE SECTION;
            int model;
            float speed;
            int ram;
            int hd;
            int screen;
            float price;

            float minSpeed;
            int minRam;
            int minHd;
            float minPrice;
        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE execCursor CURSOR FOR
            SELECT model, speed, ram, hd, screen, price, maker
            FROM Product NATURAL JOIN Laptop;

        EXEC SQL OPEN execCursor;

        printf("Enter minimum speed:");
        scanf("%f", &minSpeed);

        printf("Enter minimum ram:");
        scanf("%f", &minRam);

        printf("Enter minimum hard-drive space:");
        scanf("%f", &minHd);

        printf("Enter minimum price:");
        scanf("%f", &minPrice);

        while(1) {
            EXEC SQL FETCH FROM execCursor INTO :model,
                :speed, :ram, :hd, :screen, :price, :maker;

            if (NO_MORE_TUPLES) break;

            if (
                speed >= minSpeed &&
                ram >= minRam &&
                hd >= minHd &&
                screen >= minScreen
            ) {
                printf("model=%d, speed=%.2f, ram=%d, hd=%d, screen=%d, price=%.2f, maker=%c",
                    model, speed, ram, hd, screen, price, maker);
            }
        }

        EXEC SQL CLOSE execCursor;
    }
    \end{lstlisting}

        \item

    \begin{lstlisting}[language=c]
    #include <stdbool.h>
    #include <string.h>
    ...
    void printSpecifications() {
        EXEC SQL BEGIN DECLARE SECTION;
            int model;
            bool color;
            char printType[50];
            float price;

            float speed;
            int ram;
            int hd;
            int screen;

            char maker;
            int productModel;
            char productType[50];

            char targetMaker;
        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE execCursor CURSOR FOR
            SELECT DISTINCT maker, DISTINCT productType FROM Product;

        printf("Enter manufacturer:");
        scanf("%c", &targetMaker);

        EXEC SQL OPEN execCursor;
        while (1) {
            EXEC SQL FETCH FROM execCursor INTO :maker, :productType;

            if (NO_MORE_TUPLES) break;

            if (tolower(maker) != tolower(targetMaker)) continue;

            if (strcmp(productType,'pc')) {
                EXEC SQL DECLARE pcCursor CURSOR FOR
                    SELECT speed, ram, hd, price FROM PC
                    NATURAL JOIN Product
                    WHERE type=productType;

                EXEC SQL OPEN pcCursor;
                while(1) {
                    EXEC SQL FETCH FROM pcCursor INTO :speed,
                        :ram, :hd, :price;

                    if (NO_MORE_TUPLES) break;

                    printf("model=%d, speed=%.2f, ram=%d, hd=%d, price=%.2f, maker=%c, type=%s",
                    model, speed, ram, hd, screen, price, maker, productType);
                }
                EXEC SQL CLOSE pcCursor;

            } else if (strcmp(productType, 'laptop')) {

                EXEC SQL DECLARE laptopCursor CURSOR FOR
                    SELECT speed, ram, hd, screen, price FROM Laptop
                    NATURAL JOIN Product
                    WHERE type=productType;

                EXEC SQL OPEN laptopCursor;
                while(1) {
                    EXEC SQL FETCH FROM laptopCursor INTO :speed,
                        :ram, :hd, :screen, :price;

                    if (NO_MORE_TUPLES) break;

                    printf("model=%d, speed=%.2f, ram=%d, hd=%d, screen=%d, price=%.2f, maker=%c, type=%s",
                    model, speed, ram, hd, screen, screen, price, maker, productType);
                }
                EXEC SQL CLOSE laptopCursor;


            } else if (strcmp(productType, 'printer')) {
                EXEC SQL DECLARE printerCursor CURSOR FOR
                    SELECT color, printType, price FROM Printer
                    NATURAL JOIN Product
                    WHERE type=productType;

                EXEC SQL OPEN printerCursor;
                while(1) {
                    EXEC SQL FETCH FROM printerCursor INTO :color,
                        :printType, :price;

                    if (NO_MORE_TUPLES) break;

                    printf("model=%d, color=%s, price=%.2f, maker=%c, type=%s",
                    model, color ? "true" : "false", price, maker, type);
                }
                EXEC SQL CLOSE printerCursor;
            }
        }
        EXEC SQL CLOSE execCursor;
    }
    \end{lstlisting}

        \bigskip

    \begin{mdframed}
        \underline{\textbf{Correct Solution:}}

        \bigskip

    \begin{lstlisting}[language=c]
    #include <stdbool.h>
    #include <string.h>
    ...
    void printSpecifications() {
        EXEC SQL BEGIN DECLARE SECTION;
            int model;
            bool color;
            char printType[50];
            float price;

            float speed;
            int ram;
            int hd;
            int screen;

            char maker;
            int productModel;
            char productType[50];

            char targetMaker;
        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE execCursor CURSOR FOR
            SELECT maker, productType FROM Product
            GROUP BY maker, productType; // <- Correction

        printf("Enter manufacturer:");
        scanf("%c", &targetMaker);

        EXEC SQL OPEN execCursor;
        while (1) {
            EXEC SQL FETCH FROM execCursor INTO :maker, :productType;

            if (NO_MORE_TUPLES) break;

            if (tolower(maker) != tolower(targetMaker)) continue;

            if (strcmp(productType,'pc')) {
                EXEC SQL DECLARE pcCursor CURSOR FOR
                    SELECT speed, ram, hd, price FROM PC
                    NATURAL JOIN Product
                    WHERE type=productType;

                EXEC SQL OPEN pcCursor;
                while(1) {
                    EXEC SQL FETCH FROM pcCursor INTO :speed,
                        :ram, :hd, :price;

                    if (NO_MORE_TUPLES) break;

                    printf("model=%d, speed=%.2f, ram=%d, hd=%d, price=%.2f, maker=%c, type=%s",
                    model, speed, ram, hd, screen, price, maker, productType);
                }
                EXEC SQL CLOSE pcCursor;

            } else if (strcmp(productType, 'laptop')) {

                EXEC SQL DECLARE laptopCursor CURSOR FOR
                    SELECT speed, ram, hd, screen, price FROM Laptop
                    NATURAL JOIN Product
                    WHERE type=productType;

                EXEC SQL OPEN laptopCursor;
                while(1) {
                    EXEC SQL FETCH FROM laptopCursor INTO :speed,
                        :ram, :hd, :screen, :price;

                    if (NO_MORE_TUPLES) break;

                    printf("model=%d, speed=%.2f, ram=%d, hd=%d, screen=%d, price=%.2f, maker=%c, type=%s",
                    model, speed, ram, hd, screen, screen, price, maker, productType);
                }
                EXEC SQL CLOSE laptopCursor;


            } else if (strcmp(productType, 'printer')) {
                EXEC SQL DECLARE printerCursor CURSOR FOR
                    SELECT color, printType, price FROM Printer
                    NATURAL JOIN Product
                    WHERE type=productType;

                EXEC SQL OPEN printerCursor;
                while(1) {
                    EXEC SQL FETCH FROM printerCursor INTO :color,
                        :printType, :price;

                    if (NO_MORE_TUPLES) break;

                    printf("model=%d, color=%s, price=%.2f, maker=%c, type=%s",
                    model, color ? "true" : "false", price, maker, type);
                }
                EXEC SQL CLOSE printerCursor;
            }
        }
        EXEC SQL CLOSE execCursor;
    }
    \end{lstlisting}


    \end{mdframed}
        \item
        \item

    \begin{lstlisting}[language=c]
    #include <stdbool.h>
    #include <string.h>
    ...
    void insertNewPC() {
        EXEC SQL BEGIN DECLARE SECTION;
            int model;
            float speed;
            int ram;
            int hd;
            float price;
            char maker;

            int modelCount;
        EXEC SQL END DECLARE SECTION;

        printf("Enter manufacturer:\n");
        scanf("%c", &maker);

        printf("Enter model:\n");
        scanf("%d", &model);

        printf("Enter speed:\n");
        scanf("%f", &speed);

        printf("Enter ram:\n");
        scanf("%d", &ram);

        printf("Enter hd:\n");
        scanf("%d", &hd);

        printf("Enter price:\n");
        scanf("%f", &price);

        printf("Enter maker:\n");
        scanf("%c", &maker);

        EXEC SQL DECLARE execCursor CURSOR FOR
            SELECT COUNT(model) FROM (
                (SELECT model FROM Product WHERE model=:model)
                UNION
                (SELECT model FROM PC WHERE model=:model)
            );

        EXEC SQL OPEN execCursor;
            EXEC SQL FETCH FROM execCursor INTO :modelCount;

            if (modelCount != 0) {
                printf("Error. Model already exists in database.");
            } else {
                EXEC SQL INSERT INTO PC(model, speed, ram, hd, price)
                                VALUES(:model, :speed, :ram, :hd, :price);

                EXEC SQL INSERT INTO Product(model, maker, type)
                                VALUES(:model, :maker, "pc")
            }


        EXEC SQL CLOSE execCursor;
    }
    \end{lstlisting}

    \end{enumerate}

    \item

    \begin{enumerate}[a)]
        \item

    \begin{lstlisting}[language=c]
    void classWithLargestPower() {
        EXEC SQL BEGIN DECLARE SECTION;
            int class;
        EXEC SQL END DECLARE SECTION;

        EXEC SQL SELECT class FROM FROM Classes
            INTO :class
            WHERE numGuns * POWER(bore, 3) >= ALL (
                SELECT numGuns * POWER(bore, 3) FROM Classes
            );

        printf("Class = %s\n", class);
    }
    \end{lstlisting}

        \item

    \begin{lstlisting}[language=c]
    #include <string.h>
    ...
    void countryWithMostShipsSunk() {
        EXEC SQL BEGIN DECLARE SECTION;
            char targetBattle[255];
            char country[100];
            int count;

            char mostSunkCountry[100];
            int maxSunkCount = 0;

            char mostDamagedCountry[100];
            int maxDamagedCount = 0;

        EXEC SQL END DECLARE SECTION;

        printf("Enter name of battle:\n");
        scanf("%s", &targetBattle);

        EXEC SQL DECLARE shipsSunkCursor CURSOR FOR
            SELECT country, COUNT(Outcomes.result) FROM Classes
            INNER JOIN Ships ON Classes.class = Ships.class
            INNER JOIN Outcomes ON Ships.name = Outcomes.ship
            INNER JOIN Battles ON Battles.name = Outcome.battle
            GROUP BY country
            HAVING Battles.name=:targetBattle;
                   Outcomes.result='sunk';

        EXEC SQL DECLARE shipsDamagedCursor CURSOR FOR
            SELECT country, COUNT(Outcomes.result) FROM Classes
            INNER JOIN Ships ON Classes.class = Ships.class
            INNER JOIN Outcomes ON Ships.name = Outcomes.ship
            INNER JOIN Battles ON Battles.name = Outcome.battle
            GROUP BY country
            HAVING Battles.name=:targetBattle;
                    Outcomes.result='damaged';

        EXEC SQL OPEN shipsSunkCursor;
            while(1) {
                EXEC SQL FETCH FROM shipsSunkCursor INTO :country,
                :count;

                if (NO_MORE_TUPLES) break;

                if (count > maxSunkCount) {
                    maxSunkCount = count;
                    strcpy(mostSunkCountry, country);
                }
            }

            printf("Country with most sunk ships: %s", mostSunkCountry);

        EXEC SQL CLOSE shipsSunkCursor;

        EXEC SQL OPEN shipsDamagedCursor;
            while(1) {
                EXEC SQL FETCH FROM shipsDamagedCursor INTO :country,
                :count;

                if (NO_MORE_TUPLES) break;

                if (count > maxDamagedCount) {
                    maxDamagedCount = count;
                    strcpy(mostDamagedCountry, country);
                }
            }

            printf("Country with most damaged ships: %s", mostDamagedCountry);

        EXEC SQL CLOSE shipsDamagedCursor;

    }
    \end{lstlisting}

        \item

    \begin{lstlisting}[language=c]
    #define NO_MORE_TUPLES ! (strcmp(SQLSTATE, "02000"));

    void insertClassAndShip() {
        EXEC SQL BEGIN DECLARE SECTION;
            char class[100];
            char type[2];
            char country[100];
            int numGuns;
            int bore;
            int displacement;

            char shipName[100];
            char dateLaunched[11];

            char SQLSTATE[6];
        EXEC SQL END DECLARE SECTION;

        printf("Enter name of class:\n");
        scanf("%s", class);

        printf("Enter name of type ('bb' or 'bc'):\n");
        scanf("%s", type);

        printf("Enter name of country:\n");
        scanf("%s", country);

        printf("Enter name of numGuns:\n");
        scanf("%d", &numGuns);

        printf("Enter name of bore:\n");
        scanf("%d", &bore);

        printf("Enter name of displacement:\n");
        scanf("%d", &displacement);

        printf("Enter name of ship (if first ship, skip by pressing ENTER):\n");
        fgets(shipName, sizeof shipName,stdin);

        if (shipName[0] == '\n') {
            strncpy(shipName, class, sizeof(class));
        }

        printf("Enter date launched (YYYY-MM-DD):\n");
        scanf("%s", dateLaunched);

        EXEC SQL INSERT INTO Classes(class, type, country, numGuns, bore, displacement)
                 VALUES (:class, :type, :country, :numGuns, :bore, :displacement);

        EXEC SQL INSERT INTO Ships(name, class, launched)
                 VALUES (:shipName, :class, :dateLaunched);
    }
    \end{lstlisting}

        \item

    \begin{lstlisting}[language=c]
    #define NO_MORE_TUPLES ! (strcmp(SQLSTATE, "02000"));

    void correctError() {
        EXEC SQL BEGIN DECLARE SECTION;
            char battle[101];
            char shipName[101];
            char dateLaunched[11];
            char newDateLaunched[11];

            char dateBattle[11];
            char newDateBattle[11];

            char SQLSTATE[6];
        EXEC SQL END DECLARE SECTION;

        EXEC SQL DECLARE execCursor CURSOR FOR
            SELECT Ships.name,
                   Ships.class,
                   Ships.launched,
                   Outcomes.battle,
                   Battles.date
            FROM Ships
            INNER JOIN Outcomes ON Ships.name = Outcomes.ship
            INNER JOIN Battles ON Outcomes.battle = Battles.name
            WHERE Ships.launched > Battles.date;

        EXEC SQL OPEN execCursor;
            while(1) {
                EXEC SQL FETCH FROM execCursor INTO :shipName,
                    :class, :dateLaunched, :battle, :dateBattle;

                if (NO_MORE_TUPLES) break;

                printf("Error. Ship %s is launched after date of battle.\n");

                printf("Enter correct launched date (YYYY-MM-DD, Press enter to skip):\n");
                fgets(dateLaunched, sizeof(dateLaunched), stdin);

                if (dateLaunched[0] != '\n') {
                    // Correct date of launch
                    EXEC SQL UPDATE Ships
                             SET launched = newDateLaunched
                             WHERE name=:shipName AND
                                   class=:class AND
                                   launched=:dateLaunched;
                }

                printf("Enter correct battle date (YYYY-MM-DD, Press enter to skip):\n");
                fgets(dateBattle, sizeof(dateBattle),stdin);

                if (dateBattle[0] != '\n') {
                    // Correct date of battle
                    EXEC SQL UPDATE Battles
                             SET date = newDateBattle
                             WHERE name=:battle AND
                                   date=dateBattle;
                }
            }
        EXEC SQL CLOSE execCursor;

    }
    \end{lstlisting}

        \item

        \bigskip

        \underline{\textbf{Notes:}}

        \bigskip

        \begin{itemize}
            \item PSM
            \begin{itemize}
                \item Is also called \textbf{Persistent, Stored Modules}
                \item Is very similar to function
                \item \textbf{Syntax:}

                \bigskip

                CREATE PROCEDURE $<\text{name}>$ ($<\text{parameters}>$)

                    $<\text{local declarations}>$

                    $<\text{syntax body}>$;

                \item \textbf{Syntax \# 2:}

                \bigskip

                CREATE FUNCTION $<\text{name}>$ ($<\text{parameters list}>$) RETURNS $<\text{type}>$

                    $<\text{local declarations}>$

                    $<\text{syntax body}>$;

                \bigskip

                \underline{\textbf{Example:}}

                \bigskip

        \begin{lstlisting}[language=SQL]
        CREATE PROCEDURE Move(
            IN oldAddr VARCHAR(255),
            IN newAddr VARCHAR(255)
        )
        UPDATE MovieStar
        SET address = newAddr
        WHERE address = oldAddr;
        \end{lstlisting}

            \end{itemize}

            \item List of simple PSM statements
            \begin{itemize}
                \item Call-statement
                \item Return-statement
                \item Declarations of local variables
                \item Assignment statements
                \item Statement groups
                \item Statement labels
            \end{itemize}

        \end{itemize}

    \end{enumerate}
\end{enumerate}

\end{document}