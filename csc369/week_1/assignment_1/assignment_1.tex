\documentclass[12pt]{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{enumerate}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mdframed}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage[utf]{kotex}
\usepackage{soul}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1
}

\lstset{style=mystyle}

\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.4pt}
\lhead{Hyungmo Gu}
\rhead{CSC369 Assignment 1}

\begin{document}
\title{CSC369 Assignment 1 - Hijacking system calls and Monitoring Process}
\maketitle

\section{Overview}

\begin{itemize}
    \item

    In this assignment, you will achieve the goal of hijacking (intercepting)
    system calls by writing and installing a very basic kernel module to the Linux kernel.

    \bigskip

    Here is what ``\hl{hijacking (intercepting) a system call}'' means. You will implement
    a new \hl{system calls} named my\_syscall, which will allow you to send commands from
    userspace, to intercept another pre-existing system call (like read, write, o
    pen, etc.). After a system call is intercepted, the intercepted system call
    would log a message first before continuing performing what it was supposed to do.

    \bigskip

    For example, if we call my\_syscall with command REQUEST\_SYSCALL\_INTERCEPT
    and target system call number \_\_NR\_mkdir (which is the macro representing the
    system call mkdir) as parameters, then the mkdir system call would be intercepted;
    then, when another process calls mkdir, mkdir would log some message (e.g.,
    "muhahaha") first, then perform what it was supposed to do (i.e., make a directory).

    \bigskip

    But wait, that's not the whole story yet. Actually we don't want mkdir to log
    a message whenever any process calls it. Instead, we only want mkdir to log
    a message when a certain set of processes (PIDs) are calling mkdir. In other
    words, we want to monitor a set of PIDs for the system call mkdir. Therefore,
    you will need to keep track, for each intercepted system call, of the list of
    monitored PIDs. Our new system call will support two additional commands to add/remove
    PIDs to/from the list.

    \bigskip

    When we want to stop hijacking a system call (let's say mkdir but it can be any
    of the previously hijacked system calls), we can invoke the interceptor
    (my\_syscall), with a REQUEST\_SYSCALL\_RELEASE command as an argument and the
    system call number that we want to release. This will stop intercepting the
    target system call mkdir, and the behaviour of mkdir should go back to normal
    like nothing happened.
\end{itemize}

\section{Checklist}

\begin{itemize}
    \item

    Here is a checklist that should help get you started, and to make sure that you won't forget the important things:

    \begin{enumerate}[1.]
        \item Get your starter code
        \item Test that you have access to the VM in the CDF labs (instructions below).
        \item Download the disk image for the virtual machine here (gzipped).
              On the host computer (your laptop or a lab computer), use a virtual machine software (VirtualBox or VMware) to create a virtual machine using the the disk image you downloaded (instructions to follow below).
        \item Read and understand the existing code in the starter code. This is an important step of this assignment, and you should not start writing your own code before you have a good understanding of the starter code.
        \item Implement the new kernel module by completing source file "interceptor.c". Sections that need to be completed are marked with the TODO tag). Do NOT modify the header file "interceptor.h".
        \item Make sure to test as you go. You should first make sure that the commands to intercept and de-intercept work well, before attempting to implement the monitoring commands.
        \item Testing and debugging (must be done in the virtual machine):
        \begin{enumerate}
            \item Check out your code inside the virtual machine.
            \item Type make to compile your kernel module. Make sure there is no error or warning.
            \item Implement the intercept and release commands.
            \item Compile the test\_intercept.c program using gcc.
            \item Test your code using sudo ./test\_intercept, and make sure that all tests pass.
            \item Implement the monitoring/un-monitoring commands.
            \item Compile the\ test\_full.c program using gcc.
            \item Test your code using sudo ./test\_full, and make sure that all tests pass.
        \end{enumerate}
        \item Submit your code on time. See "Submission" for more details.
        \item Congratulations! You now have some great hands-on experience with the Linux kernel! You can now be proud of having programmed a Linux kernel module. You know what else are commonly implemented as kernel modules? Device drivers! Although they are more complex, you now technically have the basis to try to write one. Isn't that cool?
    \end{enumerate}
\end{itemize}

\section{Goal}

\begin{itemize}
    \item

    The goal of this assignment is to learn more about system calls and to use
    \hl{synchronization mechanisms}. For this assignment you will be writing a very
    basic \hl{kernel module} that intercepts system calls and monitors processes on
    demand.

\end{itemize}

\section{Requirements}

\begin{itemize}
    \item

    In order to be able to issue our own hijacking commands from userspace, we
    need a new system call that takes as parameters the command, the system call
    number (to be intercepted), and (for monitoring) a pid.

    \bigskip

    Instead of adding a new system call, which can be tricky, our new system call
    my\_syscall will be installed in place of an unused system call in the system
    call table. We will connect my\_syscall to the entry number MY\_CUSTOM\_SYSCALL
    (in effect, entry 0 which is mostly unused). The new system call my\_syscall,
    defined as follows: int my\_syscall(int cmd, int syscall, int pid); will serve
    as an interceptor and will receive the following commands from userspace:

    \bigskip

    \begin{itemize}
        \item \textbf{REQUEST\_SYSCALL\_INTERCEPT:} intercept the system call syscall
        \item \textbf{REQUEST\_SYSCALL\_RELEASE:} de-intercept the system call syscall
        \item \textbf{REQUEST\_START\_MONITORING:} start monitoring process pid for
        system call syscall, i.e., add pid to the syscall's list of monitored PIDs.
        A special case is that if pid is 0 then all processes are monitored for
        syscall, but only root has the permission to issue this command (see the
        comments for my\_syscall in the starter code for more details).
        \item \textbf{REQUEST\_STOP\_MONITORING:} stop monitoring process pid for
        system call syscall, i.e., remove pid from the syscall's list of
        monitored PIDs.
    \end{itemize}

    \bigskip

    \textbf{Kernel module operation}

    \bigskip

    Your kernel module must, upon initialization, replace the system call table
    entry for the MY\_CUSTOM\_SYSCALL number, with the my\_syscall function. When
    the module is released, it must restore this system call to its original routine.

    \bigskip

    As a result, when your kernel module is loaded, any subsequent invocations of
    the system call number MY\_CUSTOM\_SYSCALL from userspace, will issue four
    types of commands, to intercept or release a given system call, and to start
    and stop monitoring a pid for a specific syscall. You must implement the my\_syscall
    function accordingly.

    \bigskip

    \begin{enumerate}[1.]
    \item \textbf{REQUEST\_SYSCALL\_INTERCEPT and REQUEST\_SYSCALL\_RELEASE}
    \bigskip

    When an intercept command is issued, the corresponding entry in the system
    call table will be replaced with a generic interceptor function (discussed later)
    and the original system call will be saved. When a REQUEST\_SYSCALL\_RELEASE
    command is issued, the original saved system call is restored in the system
    call table in its corresponding position.

    \item \textbf{2. REQUEST\_START\_MONITORING and REQUEST\_STOP\_MONITORING}

    \bigskip

    Monitoring a process consists of the module logging into userspace some information
    about the process and the system call: the system call number, the parameters of
    the system call, and the pid of the process.

    \bigskip

    When a REQUEST\_START\_MONITORING command comes through our custom system call,
    the kernel module must record internally that the pid passed as a parameter
    should be monitored for the syscall number (passed as a parameter as well).
    The monitoring can be done for a specific pid, or for all pids (in which case
    the pid parameter for my\_syscall will be 0).

    \bigskip

    Ok, but I still don't understand, what does it mean to monitor a pid? And
    what does the generic interceptor function do?

    \bigskip

    Let's start with the monitoring. We have established that once the user issues
    a monitoring command, the kernel module records internally that pid should be
    monitored whenever it issues system call number syscall (it will be placed in
    a monitored list - see details in starter code).

    \bigskip

    We have also established that the generic interceptor function is what each
    intercepted system call will reach. In other words, whenever we reach the
    generic interceptor, we know that the system call is being intercepted
    (otherwise we would not reach this). If the pid of the process issuing the system
    call is being monitored, that means that we must print some information to a log.
    The log message will simply contain the system call number and the arguments,
    as well as the calling process's pid.

    \bigskip

    We have provided you in the starter code with a \textit{log\_message} macro,
    which takes care of sending a message to the system log. You can check the
    log using the \textit{dmesg} command.

    \bigskip

    As you might expect, regardless if a pid is monitored or not, the generic
    interceptor must eventually (once it's done logging, if applicable), call the
    original system call to allow normal operation of all processes in the system.

    \bigskip

    Alright, but what if a process exits before the user can issue a system call to stop monitoring it?

    \bigskip

    Good question! When your kernel module initializes, you should also \hl{hijack} the
    \textit{exit\_group} system call (with number \textit{\_\_NR\_exit\_group}), by
    replacing it in the \hl{system call table} with your own custom function
    \textit{my\_exit\_group}. Of course, make sure to save the original
    \textit{exit\_group} function, and to restore it when your kernel module is unloaded.

    \bigskip

    Implementing the \textit{my\_exit\_group} function should be simple: \ul{all you
    have to do is to remove the pid of the exiting process from all kernel module's
    internal bookkeeping on monitored processes, then call the original \textit{exit\_group} function}.
    \end{enumerate}
\end{itemize}

\section{Error Conditions}

\begin{itemize}
    \item

    You must make sure to check any possible misuse of the commands. In case of
    a misuse, you should return a proper error code (e.g., -EINVAL, -EPERM, google
    "Linux error code" for more information on error codes). Here is a list of
    things you should keep in mind:

    \bigskip

    \begin{enumerate}[A.]
    \item For each of the commands, check that the arguments are valid (-EINVAL):
    \begin{itemize}
        \item The syscall number must be valid: not negative, not \textgreater  NR\_syscalls (the last syscall number in the table), and not MY\_CUSTOM\_SYSCALL itself (for obvious reasons).
        \item The pid must be valid for the monitoring commands. It cannot be a negative integer, and it must be an existing pid (except for the case when it's 0, indicating that we want to start/stop monitoring for all pids).
        \item  a pid belongs to a valid process, then the following call is not NULL:
        pid\_task(find\_vpid(pid), PIDTYPE\_PID)
    \end{itemize}
    \item Check that the called has the right permissions (-EPERM):
    \begin{itemize}
        \item For the first two commands, we must be root (see the current\_uid() macro), to be able to intercept or release system calls.
        \item For the last two commands, the following logic applies:
    \begin{itemize}
        \item Is the calling process root? if so, all is good, no doubts about permissions.
        \item If it is not, then check if the pid requested is owned by the calling process
        \item Also, if pid is 0 and the calling process is not root, then access is denied (monitoring all pids should only be allowed for a superuser, for obvious reasons).
    \end{itemize}
    \end{itemize}
    \item Check for correct context of commands (-EINVAL):
    Cannot de-intercept a system call that has not been intercepted yet.
    Cannot stop monitoring for a pid that is not being monitored, or \color{red}if
    the system call has not been intercepted yet. If the system call has not been
    intercepted yet, a command to start monitoring a pid for that syscall is also
    invalid\color{black}.
    \item Check for -EBUSY conditions:
    \begin{itemize}
        \item If intercepting a system call that is already intercepted.
        \item If monitoring a pid that is already being monitored.
    \end{itemize}
    \item If a pid cannot be added to a monitored list, due to no memory being available, an -ENOMEM error code should be returned. The starter code provides a set of functions that enable operation with kernel lists.
    \end{enumerate}

    \bigskip

    What if a stop monitoring request comes in for a specific PID (let's call it P),
    for a syscall that monitors all PIDs? Is that an error or should we treat
    this as a special case? The answer is the latter, it should be treated as a
    special case, do not return an error code. If we already monitor all PIDs for
    a syscall, then you might have to think of a solution to make sure that you
    can keep monitoring all the PIDs in the system, except for P. Please keep in
    mind that some processes that will be monitored may not have even started
    their execution. Also, please keep in mind that we might have other stop
    monitoring requests for the same syscall, in which case, you might have to
    think of how to use the list of monitored pids in a smart way. One possibility
    is turning the list of monitored pids into a "blacklist" (keeping track of the
    pids that are not being monitored).
\end{itemize}

\section{General Information}

\bigskip

\begin{enumerate}[1.]
    \item You must use the starter code provided, which gives you detailed
    instructions on what you need to implement. Please make sure to implement all
    the parts indicated using detailed TODO comments. Please make sure to first do
    the tutorial which will help you write a simple kernel module and show you how
    to use printk statements for debugging. See the tutorial notes as well.
    \item Your assignment will be tested on a virtual machine on CDF. You can access
    this virtual machine from your CDF account, or you can download the provided
    virtual machine disk image and install it on your personal computer through
    a virtualization solution (for example, free software include VMWare Player,
    VirtualBox, etc.)
    \item We strongly recommend that you do NOT use the virtual machine for
    development, but rather only for testing and debugging. While working
    on this assignment, it is quite likely you will crash the kernel and although
    you can kill and restart the VM, there will be no guarantee that your code
    will still be there (the VM tools on CDF won't guarantee you safe snapshots).
    To prevent your hard work from possible data corruption make sure to at least
    back up your code periodically (e.g., by scp-ing it back to your CDF account).
\end{enumerate}

\section{Setup VM On Your Own Machine}

\bigskip

\begin{itemize}
    \item

    Note: Your assignment has to ultimately be tested on a CDF machine. However,
    if you wish to develop it and test it first on your own machine, using
    virtualization software (*do not test your assignment directly on your
    computer!*), then we will provide some basic instructions on how to do so.
    Since VirtualBox is one of the most portable (as well as free) virtualization
    software, here and here are some basic guidelines on how to install the VM
    image in VirtualBox on your computer (of course, many tutorials can be found
    online as well, so feel free to consult other sources if something does not
    work well for your own machine).
\end{itemize}


\section{Implementation Details}

\bigskip

\begin{itemize}
    \item

    \begin{enumerate}[1.]

    \item Since the number of system calls is rather small (~300), and for performance reasons, you must maintain the system call information in an array. Each array element will contain information, as described in the mytable struct:

    \begin{lstlisting}{language=c}
    typedef struct {
        asmlinkage long (*f)(struct pt\_regs);
        int intercepted;
        int monitored;
        int listcount;
        struct list\_head my\_list;
    } mytable;
    \end{lstlisting}
    \item You must use a linked list for storing information about the monitored processes; using an array of fixed size is entirely inadequate (because the search time will be the same as a linked list, the implementation complexity will be the same, but the size of the array will limit the number of entries).
    \item The system call table is exported by the void* sys\_call\_table[NR\_syscalls], present in one of the kernel source files from the VM image on CDF. If you wish to configure your own kernel image and re-compile it, you can modify the source code by adding the following two lines in the /usr/src/linux-source-2.6.32/arch/x86/kernel/i386\_ksyms\_32.c file:

    \begin{lstlisting}{language=c}
        extern void* sys_call_table[];
        EXPORT_SYMBOL(sys_call_table);
    \end{lstlisting}

    then recompile the kernel. Again, our virtual machine image already has these changes in place.
    \item Since the 2.6 kernel is preemptive, you must protect access to shared data. You will be using spinlocks for this purpose. The use of spinlocks is fairly simple and you have been shown some examples in one of the tutorials.
    \item You must use the system call number 0 for MY\_CUSTOM\_SYSCALL. Do not attempt to use a different existing system call number, as that may result in the kernel misbehaving (to say the least). Remember that lots of services running in your OS make use of these system calls.
    \item Logging the system call will be done using the \textit{log\_message} macro, defined in the interceptor.h header file.
    \item For testing, you can use the provided tester programs. After you compile a test program (the provided Makefile only compiles your interceptor module, not any tester!), remember to run the tester using sudo privileges in the VM.
    To facilitate your testing, you should first try to implement the commands to intercept and release system calls. When you are ready to test these, use the \textit{test\_intercept.c} tester.
    Once all tests pass, you can proceed to implementing the monitoring commands. To test all commands (both related to intercepting and to monitoring), you can use the \textit{test\_full.c} tester.
    \end{enumerate}

    \bigskip

    \section{Testing Your Code}

    \bigskip

    \begin{itemize}
        \item

        To help you test your code, we have provided two testers, which you will also find in your repositories. To encourage you to test as you go, we are providing you with two testers:

        \begin{itemize}
            \item \textit{test\_intercept.c} - tests if your intercept and de-intercept commands work correctly. You should first implement these and make sure the tester passes all cases.
            \item \textit{test\_full.c} - tests if all commands (including intercept, release, and both monitoring commands) work properly. This is a superset of the first tester, and you should only use once your code passes the first tester.
        \end{itemize}

        \bigskip

        The tester loads your module and tests some basic functionality. It is by no means a comprehensive tool to ensure
        your code works for every corner case. To ensure that your code works correctly in all possible scenarios, you should
        add more test cases by modifying the testers (see code comments in main). However, please do not submit your own
        tester files, because they will not be marked. The tester will also not catch synchronization bugs, except for
        blatant deadlocks. It is your responsibility to ensure that your code is not likely to run into synchonization
        problems. Finally, when testing, you will likely see the tester crash on various tests, due to bugs in your module.
        During your debugging, please feel free to go in each tester, and comment out some of the system calls being tested,
        if you wish to debug each test case in isolation.
    \end{itemize}

    \section{Other Useful Tips}

    \bigskip

    \begin{itemize}
        \item \ul{Again, run tests ONLY in the virtual machine, NOT native computer, unless you hate your laptop.}
        \item Once more, we strongly recommend that you do NOT use the virtual machine for development, but rather only for testing and debugging. Since it is quite likely you will crash the kernel and there will be no guarantee that your code will be intact. To prevent your hard work from possible data corruption make sure to at least back up your code periodically.
        \item Reading and understanding code is as important as (if not more important than) writing code.
        \item The comments in the starter code have a lot of information, make sure to read them carefully.
        \item Remember that when we de-intercept a syscall, the original system call must be restored in the system call table. For that you must properly store the original system call before replacing it.
        \item For debugging, learn how to use the \textit{printk} function, which prints messages to kernel log. See tutorial notes as well.
    Use dmesg command to check the kernel log.
    \end{itemize}
\end{itemize}

\end{document}